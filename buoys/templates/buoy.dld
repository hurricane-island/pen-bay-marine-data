StationName = $STATION_NAME ' Program for AiBUOY-V . Model Ai1BUOY-V
Const HYDROSPHERE_ID = $CLIENT_ID ' The LoginID for the Hydrosphere site.
Const PAKBUS_ADDRESS As Long = $PAKBUS_ADDRESS ' network address
Const PARAMETERS_TO_SEND = 11 ' The number of parameters that will be sent to Hydrosphere.
' 
' Wiring Details:
' YSI EXO (Uses RS485): MCBH6F. 1(Orange)=N/C, 2(Black)=GND(U3), 3(Red)=BAT, 4=N/C, 5(Yellow)=RS485B(U1), 6(White)=RS485A(U2).  RS485 Internally wired to ComRS232. 115,200 N/8/1
' Barometer Internally wired using Vx2 and A3
' RS485 Option Port (Uses RS232 via ComRS232)
' 
' Refer to section 13.3.2 "Hydrosphere Configuration" in the Ai1 manual for details on setting up the Hydrosphere parameters to suit this site
Const NONE As Long = 0: Const CELLULAR As Long = 1: Const WIFI As Long = 2: Const RADIO As Long = 3: Const IRIDIUM As Long = 4: Const TRANSPARENT As Long = 5: Const LORAWAN As Long = 6: Const RADTRANS As Long = 7: Const JOIN As Long = 0: Const CREATE As Long = 1
Const LITHIUM As Long = 1: Const LITHIUM_12V As Long = 2: Const LEAD_ACID As Long = 3: Const EXT As Long = 4: Const SUPPLY_3V3 As Float = 3.3: Const SUPPLY_5V As Float = 5: Const RISING_EDGE As Long = 1: Const HIGH_LEVEL As Long = 2: Const FALLING_EDGE As Long = 3: Const LOW_LEVEL As Long = 4 ' Types of event activationA11
Const EXO2 As Long = 2: Const EXO3 As Long = 3: Const OTT_CBS As Long = 4: Const AT200 As Long = 5: Const YSI6SERIES As Long = 6: Const ULTRA As Long = 7: Const LEVEL_4TO20 As Long = 8: Const RADAR As Long = 9: Const ULTRA_SERIAL As Long = 10: Const SUNA As Long = 11: Const VEGAPULS As Long = 12
Const SDI12 As Long = 1: Const RS232 As Long = 2: Const ANALOG As Long = 3: Const RS485 As Long = 4: Const ADD As Long = 1: Const SUBTRACT As Long = 2: Const ABSOLUTE As Long = 1: Const DIFFERENTIAL As Long = 2: Const AIRMAR As Long = 3: Const AMAZON As Long = 13: Const PROSWAP As Long = 14

Public Errors As String * 128 = "": Public Message As String * 256 = "": Public PortsStatus As String * 90: Dim PortsON As Long = 0    ' Verbose description of output ports
Const TCP_CLIENT As String = "(drema.konectgds.com,9200)" ' Pakbus Router Configuration
Public AccessPointName As String = "so01.VZWSTATIC"           ' APN for Verizon ISS

' Factory configuration constants
Const METRIC As Boolean = True                                ' Program uses SI metric units wherever possible
Const SCAN_INTERVAL_S As Long = 5 ' s                         ' Program scan Interval. 
Const MEASUREMENT_INTERVAL_S As Long = 3600 's                 ' Sensor measurement interval
Const SLOW_MEASUREMENT_INTERVAL_S As Long = 3600 's           ' Slower interval for less critical measurements, such as GPS
Const DATA_STORAGE_INTERVAL_S As Long = MEASUREMENT_INTERVAL_S ' Store data every measurement cycle
Const SENSOR_WARMUP_S As Long = 0
Public MeasureBefore_s As Long = 0
PreserveOneVariable(MeasureBefore_s) ' The time to warm up the sensor before measuring (in s).  Set to 0 to have always on
Const LOW_BATTERY_SAVER_V = 12.83: Const LOW_BATTERY_SHUTDOWN_V = 12.75' V  ' Battery protection thresholds.  SAVER: Slow meas/no night comms.  SHUTDOWN: Slowest meas/No comms
Const COMMS As Long = CELLULAR
Const CELL_WINDOW_START As Long = 1440
Const CELL_WINDOW_DURATION As Long = 10
Const CELL_WINDOW_FREQUENCY As Long = 1440  ' Modem is always on when CELL_WINDOW_START = 1440
Const CURRENT_ZERO_mV As Long = 1250 ' mV.                    ' Factory calibrated.  To recalibrate: Remove fuse and power Ai1 from charging input, measure Current_mV
Const A3_RATIO As Float = 1.000                               ' Factory calibrated.  2:1 voltage divider fitted on A3
Const SENSOR_QTY As Long = 1  ' Number of sensors fitted to this station, repeat the measurements on sequential ports or address
Const GPS_INTERFACE As Long = RS232
Const TABLE_WQ As Long = 200000
Const SONDE_USED As Boolean = TRUE
Const SONDE_USES_RS485 As Boolean = True
Const SONDEVALUES_TBL_SIZE As Long = 5000
Const PRESSURE_TYPE As Long = ABSOLUTE
Const PRESSURE_FSR_PSI As Float = 43.5
Const TRANSFER As Float = 0.1 ' Pressure sensor configuration

' Available                                                   ' A1 Terminal (SE1)
' Available                                                   ' A2 Terminal (SE2)
Const PRESSURE_PORT As Long = 3
Const PRESSURE_INTERFACE As Long = ANALOG   ' A3 Terminal (SE3). Internal pressure sensor.  Absolute sensor requires 2:1 voltage divider
' Available                                                   ' Internal SE4
                                                              ' Vx1. Vx1 used for powering RS485 adapter, 5V.
' Internal Sensor Power Port                                  ' Vx2. Internal functions expect this to be 5V
Const SENSOR_POWER_PORT As Long = SW12V                       ' SW12. Used for controlling power to sensors
' Available                                                   ' C1. Recommended to keep for SDI12 in the future
Const GPS_PORT As Long = ComC2_Rx                             ' C2. Serial Rx from GPS
Const YSIPPORT As Long = ComRS232
Public Ai1WipesSonde As Boolean = True
PreserveOneVariable(Ai1WipesSonde) ' RS232 Port with RS485 adapter
' Available                                                   ' P_SW.
' Available                                                   ' P_LL.  Can not be used for output.

Dim ParameterToSend(PARAMETERS_TO_SEND) As Long               ' A pointer of type long that points to the address of each variable to send
Public ExternalTemp As Float                                  ' First reading from the sonde, use this instead of External_Temp
Include "CPU:YSIP_CONST_Enc.CR300"
Include "CPU:YSIP_CORE_Enc.CR300"

Dim Ai1OSVersion As Float = 0.75
Dim DataloggerOSVersion As Float                              ' Used for holding CR300 OS version
Const FILTER_FREQUENCY As Long = 4000                         ' Set to 50 or 60 for situations with AC noise, otherwise 4000Hz provides quickest processing
' General Constants to aide readability
Const READ_COILS As Long = 1
Const READ_DISCRETE_INPUTS As Long = 2
Const READ_HOLDING_REGISTERS As Long = 3
Const READ_INPUT_REGISTERS As Long = 4
Const WRITE_SINGLE_COIL As Long = 5
Const WRITE_SINGLE_REGISTER As Long = 6
Const WRITE_MULTIPLE_COILS As Long = 15
Const WRITE_MULTIPLE_REGISTERS As Long = 16
Const RTU_32_FLOAT_OR_LONG_CDAB As Long = 0
Const RTU_16_SIGNED_INTEGER As Long = 1
Const RTU_32_FLOAT_OR_LONG_ABCD As Long = 2
Const RTU_16_UNSIGNED_INTEGER As Long = 3
Const ASCII_4_BYTES_CDAB As Long = 10
Const ASCII_2_BYTES As Long = 11
Const ASCII_4_BYTES_ABCD As Long = 12
Const TIMER_STOP As Long = 1
Const TIMER_RESET_AND_START As Long = 2
Const TIMER_RESET_AND_STOP As Long = 3
Const TIMER_READ As Long = 4
Const ALLOW_SLEEP As Long = 1
Const GPS_TIMER As Long = 11
Const WEB_TIMER As Long = 12
Const SENSOR_TIMER As Long = 13
Const PUMP_TIMER As Long = 14
Const IRIDIUM_TIMER As Long = 15
Const MODBUS_TIMER As Long = 16
Const DISPLAY_TIMER As Long = 17
Const SAMPLER_TIMER As Long = 18
Const INSITU_SENSOR_TIMER As Long = 19
Const EVENT_TIMER As Long = 20
Const ONE_SHOT As Long = 0
Const TIME_BASED As Long = 1
Const RISING_STAGE As Long = 2
Const RISING_AND_FALLING_STAGE As Long = 3 ' Types of sampler activation
Const CRLF = CHR(13) + CHR(10)
Const CR = CHR(13)
Const LF = CHR(10)
Const SPACE = CHR(32)
Const ESC = CHR(27)
Const hPa_TO_m As Float = 0.0101972
Const PSI_TO_hPa As Float = 68.94757
Const FORWARD As Long = 1
Const REVERSE As Long = 2
Const STOPPED As Long = 0
Const RUNNING As Long = 1
Const CURRENT_PORT As Long = 5
Const HUMIDITY_PORT As Long = 6


Const READ_ATTEMPTS_LIMIT As Long = 4
Public ReadAttempts As Long                                   ' Keep track of how many times the sensor read was attempted
Dim ProgramCounter As Long: Units ProgramCounter = Cycles     ' Keep track of how many program cycles since power up
Dim LastProgramCounter As Long: Units LastProgramCounter = Cycles
Public BatteryVoltage As Float: Units BatteryVoltage = Volts
Dim Vx1Voltage As Long
Dim Vx2Voltage As Long                ' Keep track of the excitation port voltage so that it can safely be turned off after status readings  
Const PRESSURE_SUPPLY As Float = 5.0                          ' All use 5V for maximum output
Const PRESSURE_ZERO_OFFSET As Float = TRANSFER * PRESSURE_SUPPLY
Const PRESSURE_FSR As Float = (1 - TRANSFER) * PRESSURE_SUPPLY
Const PRESSURE_PARAMETERS As Long = 3
Public Pressure(PRESSURE_PARAMETERS) As Float
Alias Pressure(1) = Pressure_Voltage: Units Pressure_Voltage = Volts
Alias Pressure(2) = Pressure_hPa: Units Pressure_hPa = hPa
Alias Pressure(3) = Pressure_mH2O: Units Pressure_mH2O = mH2O
Const PRESSURE_READINGS As Long = 7                           ' Number of measurements to take from averaging this single reading
Const PRESSURE_TIME_AVERAGING As Long = 5                     ' The period over which to take time averaged pressure readings
Dim PressureArray(PRESSURE_READINGS) As Float                 ' Array to hold readings from which the median value is used
Dim PressureTimeArray(PRESSURE_TIME_AVERAGING) As Float       ' Array to hold the time series of median filtered readings
Dim PressureTimeArraySorted(PRESSURE_TIME_AVERAGING)          ' To hold the sorted values for median selection
Dim PressureFirstReading As Boolean = True                    ' First time through, copy the initial value to all elements in array
Public Current_mA As Long: Units Current_mA = mA              ' Use long so that only whole numbers are returned
Dim Current_mV As Float: Units Current_mV = mV
Public InternalTemperature As Float: Units InternalTemperature = °C
Public InternalHumidity As Long: Units InternalHumidity = % ' Report only whole numbers
Public HumidityVoltage As Float: Units HumidityVoltage = mV
Public ProcessingTime: Units ProcessingTime = µS
Dim rTime(9): Alias rTime(1) = Year: Alias rTime(2) = Month: Alias rTime(3) = DayOfMonth: Alias rTime(4) = Hour: Alias rTime(5) = Minute: Alias rTime(6) = Second: Alias rTime(7) = uSecond: Alias rTime(8) = WeekDay: Alias rTime(9) = DayOfYear
Dim i As Long ' For internal counters only
Dim AddressToRead As Long                                     ' Used by several subroutines, for holding a memory address for a pointer
Dim ValueToLoad As Float                                      ' Internal processing only, the value at the pointer address in Float form

Sub AddTime                                                   ' Adds time onto end of message, formatted to H:MM:SS
  Message += Hour + ":": If Minute < 10 Then Message += "0" 
  Message += Minute + ":": If Second < 10 Then Message += "0"
  Message += Second
EndSub  

Sub AddDate
  Message += ", " + DayOfMonth + "/" + Month + "/" + Year + "."
EndSub 

Sub AddSeparator
  If Right(PortsStatus,1)=":" Then PortsStatus += " " Else PortsStatus += ", "
EndSub

Sub WritePort(PortToWrite As Long, StateToWrite As Boolean)   ' Fixes the problem with PortSet which can not run in conditional loops, call with PortToWrite as C1/C2/SE1/SE2/SE3/SE4/SW12V/Vx1/Vx2
  Dim StateMask As Long = 0
  Select Case PortToWrite  
  Case C1
    If StateToWrite Then StateMask = &B00000001 Else StateMask = 0
    Message = "Setting C1 to ": If StateToWrite Then Message += "ON (5V)" Else Message += "OFF"
    WriteIO(&B00000001, StateMask)
  Case C2
    If StateToWrite Then StateMask = &B00000010 Else StateMask = 0
    Message = "Setting C2 to ": If StateToWrite Then Message += "ON (5V)" Else Message += "OFF"
    WriteIO(&B00000010, StateMask)
  Case SE1
    If StateToWrite Then StateMask = &B00000100 Else StateMask = 0
    Message = "Write to SE1 not supported or analog read instructions result in compilation failure. ": Call AddTime: Errors = Message ' Don't use ErrrorLog as it may be repeated
  Case SE2
    If StateToWrite Then StateMask = &B00001000 Else StateMask = 0
    Message = "Write to SE2 not supported or analog read instructions result in compilation failure. ": Call AddTime: Errors = Message ' Don't use ErrrorLog as it may be repeated
  Case SE3 ' SE3 uses a different technique to drive regulators.  On is achieved by setting the port to high impedance (i.e. as an input).  Off is an output in the off state
    If StateToWrite Then StateMask = &B00010000 Else StateMask = 0
    Message = "Write to SE3 not supported or analog read instructions result in compilation failure. ": Call AddTime: Errors = Message ' Don't use ErrrorLog as it may be repeated
  Case SE4 ' SE4 uses same technique as SE3, high impedance / 0V setting, using regulator internal pull up resistor
    If StateToWrite Then StateMask = &B00100000 Else StateMask = 0
    If StateToWrite Then 
      PortsConfig(&B00100000,&B00000000) ' This sets port as an input which float ons via regulator pull-up
      Message = "Setting SE4 to an input (high impedance, turns regulator on)"
    Else
      WriteIO(&B00100000,StateMask)  ' This drives the output to 0V, turning off the regulator 
      Message = "Setting SE4 to off (turns regulator off)" 
    EndIf
  Case SW12V  ' This equates to 7
    If StateToWrite Then StateMask = &B01000000 Else StateMask = 0
    Message = "Setting SW12V to ": If StateToWrite Then Message += "ON (12V)" Else Message += "OFF"
    WriteIO(&B01000000, StateMask)
  Case P_SW ' 8
    If StateToWrite Then StateMask = &B10000000 Else StateMask = 0
    Message = "Write to P_SW not supported or PulseCount instructions result in compilation failure. ": Call AddTime: Errors = Message ' Don't use ErrrorLog as it may be repeated
  Case Vx1                                                    ' Vx1/Vx2 do not use WriteIO, it must set to the desired state
    If StateToWrite Then Vx1Voltage = 5000 Else Vx1Voltage = 0 ' Vx1 is either 5V or 0V
    Message = "Setting Vx1 to " + (Vx1Voltage/1000) + "V"
    ExciteV(Vx1,Vx1Voltage,0) 
  Case Vx2                                                    ' Vx2 has high power regulator as well.  Due to enable/disable circuit Vx2 can not be fully turned off. Anything >400mV is accurate.  
    If StateToWrite Then Vx2Voltage = 3300 Else Vx2Voltage = 0 ' Vx2 is either 3.3V or 0V
    Message = "Setting Vx2 to " + (Vx2Voltage/1000) + "V"
    ExciteV(Vx2,Vx2Voltage,0)
  Case Is <= 0 
    Message = "Error, specifiy port to use"
  Case Else
    Call ErrorLog("Port not recognised.  Port: " + PortToWrite + ", State: " + StateToWrite) ' Write to errors so this doesn't disappear
  EndSelect
  If PortToWrite = VX1 Then PortToWrite = 9  ' Change from 101 to 512 so bitwise logic works
  If PortToWrite = VX2 Then PortToWrite = 10 ' Change from 102 to 1024 so bitwise logic works
  If StateToWrite Then  ' If turning a port on
    If (PortsON AND (2^PortToWrite)) Then ' Bitwise test current state of PortToWrite in PortsON
      Message += ". Port was already on (no change)"
    Else
      Message += ". Port was off (now on)"
      PortsON = PortsON + (2^PortToWrite)
    EndIf
  Else                  ' If Turning a port off
    If (PortsON AND (2^PortToWrite)) Then
      Message += ". Port was on (now off)"
      PortsON = PortsON - (2^PortToWrite)
    Else
      Message += ". Port was already off (no change)"
    EndIf
  EndIf
   
  If PortsON = 0 Then
    PortsStatus = "All ports off."
  Else ' C1=1(2), C2=2(4), SE1=3(8), SE2=4(16), SE3=5(32), SE4=6(64), SW12V=7(128), P_SW=8(256), VX1=101=>9(512), VX2=102=>10(1024)
    PortsStatus = "Ports ON:"
    If (PortsON AND 2^C1) Then 
      Call AddSeparator: PortsStatus += "C1"
    EndIf
    If (PortsON AND 2^C2) Then
      Call AddSeparator: PortsStatus += "C2"
    EndIf
    If (PortsON AND 2^SE1) Then
      Call AddSeparator: PortsStatus += "SE1"
    EndIf
    If (PortsON AND 2^SE2) Then
      Call AddSeparator: PortsStatus += "SE2"
    EndIf
    If (PortsON AND 2^SE3) Then
      Call AddSeparator: PortsStatus += "SE3"
    EndIf
    If (PortsON AND 2^SE4) Then
      Call AddSeparator: PortsStatus += "SE4"
    EndIf
    If (PortsON AND 2^SW12V) Then
      Call AddSeparator: PortsStatus += "SW12"
    EndIf
    If (PortsON AND 2^P_SW) Then
      Call AddSeparator: PortsStatus += "PSW"
    EndIf
    If (PortsON AND 2^9) Then
      Call AddSeparator: PortsStatus += "VX1(5V)"
    EndIf
    If (PortsON AND 2^10) Then
      Call AddSeparator: PortsStatus += "VX2"
    EndIf
    Battery(BatteryVoltage)
    If BatteryVoltage = 0 Then PortsStatus += ". Output levels reduced when running on USB power." Else If BatteryVoltage < 11 Then PortsStatus += ". Output levels may be reduced when battery is flat."
  EndIf
  Message += ". ": Call AddTime: Message +=". "
EndSub


Dim CommsPowerOnStatus As Boolean = True                      ' CommsPowerOnStatus returns the state of the internal cellular modem power when controlled by battery saver and shutdown settings, but does not indicate the state due to window duration and frequency.  IPNetPower overrides all other power control options
Dim CellBillingDay = 1 ' Day of Month                         ' For data usage calculations, to know which day of month the billing cycle resets
Public Control_____________ As Boolean = False                ' This groups all the program control flags into one section for ease of use
Dim ReadGPSNow As Boolean = False: Units ReadGPSNow = True = Trigger a new GPS reading ' Set by setting ReadStatusSensors true
Dim SendToHydrosphere As Boolean                              ' Set true to initiate data record and transfer.  Also set true after StoreData routine

Sub Communications
  RealTime(rTime)                                             ' Have If time statements at the top so none are missed from long scan times
  Call Hydrosphere
EndSub ' Sub Communications

Public ReadFast As Boolean = False: Units ReadFast = True = Read each Scan interval
Public ReadNow As Boolean = False: Units ReadNow = True = Trigger A New Sensor Reading
Public ReadPause As Boolean = False: Units ReadPause = True = Pause New Sensor Readings
Public ReadStatusSensors As Boolean = False
Public StoreData As Boolean = False: Units StoreData = True = Save Data Record  ' Allows program control (time and event based) as well as user control
Public ForceStoreData As Boolean = False
Public SensorHoldPowerOn As Boolean = False: Units SensorHoldPowerOn = True = Keep Sensor On
Public SensorHoldPowerOff As Boolean = False: Units SensorHoldPowerOff = True = Keep Sensor Off
Public SensorKeepRS485On As Boolean = False                   ' Set true if power is to be kept on between readings.  May be useful to see the full boot-up message from the sonde.  No, it stops this working at all.  Only get a couple of bytes, 00 FF
Dim SensorKeepRS485OnLast As Boolean = False                  ' Keep track of when this is first turned on, so you can power up the adapter
Dim SensorProgramOn As Boolean = False: Dim SensorProgramOff As Boolean = False ' Program controlled power operation 
Public Measurements________ As Boolean = False
Dim SensorPowerStatus: Units SensorPowerStatus = Returns True If Sensor Is ON ' No longer need this public, have PortsStatus
Public GPSPowerStatus As Boolean
Units GPSPowerStatus = Returns True If GPS Is ON ' Have the GPS power status appear next to the sensor power status
Const GPS_BAUD As Long = 9600
Const GPS_BUFFER As Long = 512                                ' The uBlox GPS outputs a lot more messages, allow a bigger string.  400
'---WATER-QUALITY---------------------------------------------
Public SondeReadFailed As Boolean = False
Const DONT_STORE_WQ_TABLE As Boolean = True                   ' Don't store WQ data table, this is done in the YSPI program
Dim WQTemporaryRS485(YSISWATH) As Float                       ' A temporary array to be used to hold returned values prior to confirming as valid
Alias SondeValuesSorted(45) = Sonde_Future1
Alias SondeValuesSorted(46) = Sonde_Future2
Alias SondeValuesSorted(47) = Sonde_Future3
Alias SondeValuesSorted(48) = Sonde_Future4
Alias SondeValuesSorted(49) = Sonde_Future5
Alias SondeValuesSorted(50) = Sonde_Future6
Alias SondeValuesSorted(51) = Sonde_Future7
Alias SondeValuesSorted(52) = Sonde_Future8
Alias SondeValuesSorted(53) = Sonde_Future9
Alias SondeValuesSorted(54) = Sonde_Future10
Alias SondeValuesSorted(55) = Sonde_Future11
Alias SondeValuesSorted(56) = Sonde_Future12
Alias SondeValuesSorted(57) = Sonde_Future13
Alias SondeValuesSorted(58) = Sonde_Future14
Alias SondeValuesSorted(59) = Sonde_Future15
Alias SondeValuesSorted(60) = Sonde_Future16
Const USE_WQ As Boolean = True

Sub MeasureWaterQuality
  Message = "Powering RS485 adapter for communications"
  Call WritePort(Vx1,True)                                    ' Turn on the RS485 adapter, if not already
  Delay(0,200,mSec)                                           ' Short delay to allow sonde to wake up
  WQTemporaryRS485() = SondeValuesSorted()                    ' Save the previous values incase this fails for any particular reason
  If NOT sondefound Then findSonde(3)                         ' If the sonde hasn't been found, then attempt to find first
  If Ai1WipesSonde Then                                       ' When using Sample&Hold in the sonde, the sonde controls the wiping frequency, no need to duplicate here
    Message = "Allowing time for sonde wiper."
  	startWipe()                                                ' Wipe the sonde, full wipe is 2 in each direction, takes approximately 22s, although have seen errors on stations with 25s (Tapas)
  	getWipeStatus()
  	For i = 40 To 1 Step -1
  	  Delay(0,1,Sec)                                           ' Wait for sonde to power up
  	  Message = "Allowing time for sonde wiper (" + i + "s remaining)"
  	Next i
  EndIf
  Message = "Reading sonde and updating available parameters. "
	sondeCheck(): getSondeParams()                               ' Handle any sonde changes and update parameters
	ReadAttempts = 0
	Do
	  ReadAttempts += 1
	  Message = "Reading sonde values, attempt " + ReadAttempts
	  Sonde_External_Voltage = NaN: External_Temp = NaN: Depth = NaN ' Prepare parameters to check with NaN so that a successful read is identified
	  getSondeValues()                                           ' Populate available sonde parameters
	  sortYSIPData()
	  ExternalTemp = External_Temp                               ' Map the temperature reading so that Hydrosphere and Satellite naming will work
	  SondeReadFailed = False
	  If (Sonde_External_Voltage = NaN) AND (WiperPosition = NAN) Then SondeReadFailed = True ' NAN's occur if there is no communications to sonde
	  If (Sonde_External_Voltage = 0)   AND (WiperPosition = 0)   Then SondeReadFailed = True ' 0's can occur if the sonde has failed to measure sensors yet, but ready to talk
	Loop While (SondeReadFailed AND (ReadAttempts <= READ_ATTEMPTS_LIMIT)) ' Repeat if the read failed (any non-NaN value will mark success)
	If SondeReadFailed Then                                      ' We didn't get a single valid reading, so map in the previous values
	  SondeValuesSorted() = WQTemporaryRS485()
	  Message = "No valid Data ("
    If Sonde_External_Voltage = NaN Then 
      Message += "NAN returned"
    ElseIf Sonde_External_Voltage = 0 Then Message += "Zero's returned"
      Message += "Unspecified response"
    EndIf
    Message += "), restoring previous values. ": Call AddTime: Call AddDate: Errors = Message ' Message only, not logged
 	Else
	  Message = "Sonde read completed"
	  getSondeSN()
	  CallTable SondeValues                                      ' Only store sonde values if the read was successful so we don't store NAN's or 0's
  EndIf
	CallTable YSISondeMeta
	If SensorKeepRS485On Then
	  Message += ".  Keeping RS485 powered on (override by SensorKeepRS485On)" ' Set by program control for testing.  High power.
	Else
    Message += ".  Shutting down RS485 adapter"
  	Call WritePort(Vx1,False)                                  ' Turn off the RS485 adapter, allows the sonde to stay in lower power state
  EndIf
EndSub


Const HYDROSPHERE_HOST As String = "stormcentral.waterlog.com"
Const HYDROSPHERE_PORT As Long = 32212
Const HYDROSPHERE_MAX_RETRIES As Long = 5                     ' Number of retries for Hydrosphere connection attempts
Const HYDROSPHERE_BUFFER_SIZE As Long = 96                    ' How many sets of readings can be stored/Bufferd in the logger waiting for good comms.  96 is required for 15min data, for 12 hours - if daily updates are used
Const HYDROSPHERE_TIMEOUT As Long = 500 ' x 0.01s, i.e. 5s
Public HydrosphereID_EditInProgram As String = HYDROSPHERE_ID ' The ID in the form of abcde-abcde-abcde-abcde, defined in main program
Public HydrosphereData As String *(22+PARAMETERS_TO_SEND*10) ' The string representing one full record to send to Hydrosphere
Public HydrosphereDataBuffer(HYDROSPHERE_BUFFER_SIZE) As String *(22+PARAMETERS_TO_SEND*10) ' A small buffer of records to send to Hydrosphere
Public HydrosphereNames As String *(PARAMETERS_TO_SEND*26)' The combined descriptions into a single string
Dim HydrosphereBufferNextPointer As Long = 1

Dim HydrosphereDescription(PARAMETERS_TO_SEND) As String * 26 ' The string description of each parameter, up to 24 characters in length 
Dim HydrosphereValues(PARAMETERS_TO_SEND) As Float        ' The actual values to send
Dim HydrosphereSocket As Long
Dim SerialOutResult As Long
Dim HydrosphereRetries As Long

Sub Hydrosphere
  If SendToHydrosphere = True Then
    HydrosphereRetries = 0 ' Send the buffer
    Message = "Hydrosphere (": Call AddTime: Message += "). "
    HydrosphereID_EditInProgram = HYDROSPHERE_ID
    If HydrosphereBufferNextPointer > 1 Then
      Do While HydrosphereBufferNextPointer > 1 AND HydrosphereRetries < HYDROSPHERE_MAX_RETRIES
        HydrosphereRetries += 1
        HydrosphereSocket = TCPOpen(HYDROSPHERE_HOST,HYDROSPHERE_PORT,1000,HYDROSPHERE_TIMEOUT)
        If HydrosphereSocket <> 0 Then
          SerialFlush(HydrosphereSocket)
          SerialOut(HydrosphereSocket,"SL(" + HYDROSPHERE_ID + ")" + CR,"OK",1,HYDROSPHERE_TIMEOUT)
          SerialOut(HydrosphereSocket,HydrosphereNames,"OK",1,HYDROSPHERE_TIMEOUT)
          SerialOutResult = SerialOut(HydrosphereSocket,HydrosphereDataBuffer(1),"OK",1,HYDROSPHERE_TIMEOUT)
          SerialOut(HydrosphereSocket,"DIS" + CR,"OK",1,HYDROSPHERE_TIMEOUT)
          TCPClose(HydrosphereSocket)
        Else
          Message += "No connection. "
          SerialOutResult = 0 ' Make sure that the last OK is not still in the status
        EndIf
        If SerialOutResult = 2 Then ' If "OK" was sent
          If HydrosphereBufferNextPointer > 2 Then            ' If we still have at least 2 data values in the Buffer (one of which was just sent), move the Buffer forward by one.
            For i = 1 To (HydrosphereBufferNextPointer - 2)
              HydrosphereDataBuffer(i) = HydrosphereDataBuffer(i+1)
            Next i
          EndIf
          HydrosphereDataBuffer(HydrosphereBufferNextPointer-1) = "" ' Clear the details of the last Message from the Buffer (as they have been shifted forward by one now).
          HydrosphereBufferNextPointer = HydrosphereBufferNextPointer - 1
          Message += "Report " + HydrosphereBufferNextPointer + " sent. "
        Else
          Message += "No OK (" + SerialOutResult + "). "
          If HydrosphereRetries = HYDROSPHERE_MAX_RETRIES Then Message += "Failed. " + HydrosphereRetries + "/" + HYDROSPHERE_MAX_RETRIES + " tries."
        EndIf ' End if "OK" was sent
      Loop
    Else
      Message += "No data to send. Use StoreData first. "
    EndIf ' If HydrosphereBufferNextPointer > 1
    SendToHydrosphere = False
  EndIf ' If SendToHydrosphere = True
EndSub ' Hydrosphere

Sub SensorMeasurements  ' Time commands at the top, so slow commands don't interfere
  If TimeIntoInterval(0,DATA_STORAGE_INTERVAL_S,Sec) Then StoreData = True
  If TimeIntoInterval(0,1,Day) Then
    ReadPause = False
    ReadFast = False
  EndIf
  If ReadNow Then                                             ' If ReadNow is on here then it is set manually, not by program control
    If SensorPowerStatus = False Then
      Call WritePort(SENSOR_POWER_PORT,True)
      SensorPowerStatus = True
      ' The duration of the delay depends on the instrument.  Some power up quickly (ultrasonic <1s, Display <2s), some take a long time (EXO takes 30s before responding to SDI12)
      Message = "Sensor always on, delay for 2s only"
      Delay(0,2,Sec)                                          ' Ultrasonic needs 0.35s.  Display needs 2s.  This will throw out subsequent time instructions, but manual readings don't happen often
    EndIf ' If SensorPowerStatus
    StoreData = True                                          ' Store data from this reading as well
    If SENSOR_WARMUP_S > 0 Then SensorProgramOff = True       ' Turn off power at the end of the manual reading
  EndIf
  If MeasureBefore_s > 0 Then
    If TimeIntoInterval((MEASUREMENT_INTERVAL_S - MeasureBefore_s),MEASUREMENT_INTERVAL_S,Sec) Then ReadNow = True ' If MeasureBefore_s is non zero, it takes measurement before the interval so it is ready
  Else
    If TimeIntoInterval(0,MEASUREMENT_INTERVAL_S,Sec) Then ReadNow = True
  EndIf
  If TimeIntoInterval(0,MEASUREMENT_INTERVAL_S,Sec) Then SensorProgramOn = True ' Sensor is always powered on
  If NOT(SensorHoldPowerOff) AND (SensorHoldPowerOn OR SensorProgramOn OR ReadFast) Then ' Turn on if instructed by either the user or the program.  Turning off is after the measurement
    If SensorPowerStatus = False Then                         ' Only turn it on if it is not already
      Call WritePort(SENSOR_POWER_PORT,True)
      SensorPowerStatus = True
    EndIf
    SensorProgramOn = false ' Only do this once
  EndIf
  If (ReadNow OR ReadFast) AND NOT(ReadPause) Then
    Call MeasureWaterQuality
    ReadNow = false
  EndIf

  If StoreData Then ' Needs to be separate so it can store exactly at the interval
    ' StoreData does not store data with RS485 sondes, must take measurements first, and measurements must be valid or CallTable is skipped (see above)
    Call LoadData ' Load the array for addresses of variables to use
    For i = 1 To PARAMETERS_TO_SEND
      HydrosphereDescription(i) = !(ParameterToSend(i)) ' name of memory location is the canonical vendor name
      AddressToRead = (ParameterToSend(i)) ' Cannot read the value directly
      HydrosphereValues(i) = !AddressToRead
    Next i
    RealTime(rTime)
    HydrosphereData = "D=" + FormatFloat(Month,"%02.0f") + "/" + FormatFloat(DayOfMonth,"%02.0f") + "/" + FormatFloat((Year MOD 100),"%02.0f") + "," + FormatFloat(Hour,"%02.0f") + ":" + FormatFloat(Minute,"%02.0f") + ":" + FormatFloat(Second,"%02.0f") + ","
    HydrosphereNames = "SN="
    For i = 1 To PARAMETERS_TO_SEND
      HydrosphereNames += HydrosphereDescription(i)
      HydrosphereData += HydrosphereValues(i)
      If i < PARAMETERS_TO_SEND Then 
        HydrosphereData += ","
        HydrosphereNames += ","
      EndIf
    Next i
    If HydrosphereBufferNextPointer <= HYDROSPHERE_BUFFER_SIZE Then
      HydrosphereDataBuffer(HydrosphereBufferNextPointer) = HydrosphereData + CR
      HydrosphereBufferNextPointer += 1
    EndIf
    SendToHydrosphere = True  ' If new data has been saved, then next time through, send it to Hydrosphere
    StoreData = False                                         ' Only do this one time
  EndIf
  If ForceStoreData Then
    CallTable SondeValues              ' This can force data storage for processes like FTP that won't do a transfer
    ForceStoreData = False
  EndIf
  If NOT(SensorHoldPowerOn) AND (SensorHoldPowerOff OR SensorProgramOff) Then
    If SensorPowerStatus Then                                 ' Only turn off if currently on
      Call WritePort(SENSOR_POWER_PORT,False)
      SensorPowerStatus = False
    EndIf
    SensorProgramOff = False                                  ' Only do this once
  EndIf
    If SensorKeepRS485On AND NOT(SensorKeepRS485OnLast) Then
      Message = "Turning on RS485 adapter based on SensorKeepRS485On setting"
      Call WritePort(Vx1,True)
    EndIf
    If NOT(SensorKeepRS485On) AND SensorKeepRS485OnLast Then
      Message = "Turning off RS485 adapter based on SensorKeepRS485On setting"
      Call WritePort(Vx1,False)
    EndIf
    SensorKeepRS485OnLast = SensorKeepRS485On
EndSub


Const GPS_PARAMETERS As Long = 9                              ' 1=Time(UTC),2=Date,3=Lat(ddmm),4=Lat(.mmmmmm),5=Long(ddmm),6=Long(.mmmmmm),7=Alt,8=Fix,9=#Sat
Dim GPSReadings(GPS_PARAMETERS) As Float
Public GPSString As String * GPS_BUFFER: Units GPSString = NMEA 0183 Processed String
Const GPS_HEADER As String = "$GPGGA"                         ' This is the header of the GPS string
Dim CommaCount As Long                                        ' Use to make sure I have enough data
Dim GPSReadingsString(GPS_PARAMETERS) As String * 16
Dim RawGPSString As String * GPS_BUFFER: Units RawGPSString = NMEA 0183 String buffer
Dim GPSStart As Long: Units GPSStart = Start character For NMEA Message
Dim GPSEnd As Long: Units GPSEnd = End character For NMEA Message
Dim GPSLength As Long: Units GPSLength = characters in NMEA Message
Dim Comma1 As Long: Dim Comma2 As Long: Dim InternalCounter As Long
Alias GPSReadings(1) = GPS_UTCtime: Units GPS_UTCtime = HHMMSS
Alias GPSReadings(2) = GPS_Latitude_dddmm: Units GPS_Latitude_dddmm = dddmm.mmmm
Alias GPSReadings(3) = GPS_LatitudeHemisphere: Units GPS_LatitudeHemisphere = 1=N, -1=S
Alias GPSReadings(4) = GPS_Longitude_dddmm: Units GPS_Longitude_dddmm = dddmm.mmmm
Alias GPSReadings(5) = GPS_LongitudeHemisphere: Units GPS_LongitudeHemisphere = 1=E, -1=W
Alias GPSReadings(6) = GPS_QualityIndicator: Units GPS_QualityIndicator = 0=NoFix,1=GPS,2=DIFFERENTIAL
Alias GPSReadings(7) = GPS_Satellites: Units GPS_Satellites = count
Alias GPSReadings(8) = GPS_HDOP: Units GPS_HDOP = error estimate
Alias GPSReadings(9) = GPS_Height: Units GPS_Height = meters
Public Latitude As Float: Units Latitude = Decimal Degrees (N=+,S=-)  ' Latitude recombined into a single value.  These are what are stored in the data tables
Public Longitude As Float: Units Longitude = Decimal Degrees (E=+,W=-)
Public UTCTime As Long: Units UTCTime = HHMMSS
Dim UTCDate As Long: Units UTCDate = YYMMDD
Dim GPSFix As Long: Units GPSFix = 0=No FIX, 1=FIX, 2=DIFFERENTIAL FIX
Public GPSSatellitesInView As Long: Units GPSSatellitesInView = GPS Satellites visible
PreserveOneVariable(Latitude): PreserveOneVariable(Longitude) ' Save these values so a power cycle does not reset them and cause the icon to jump around
Public GPSSatellitesRequired As Long = 4: PreserveOneVariable(GPSSatellitesRequired) ' Specifies the required satellites for an accurate GPS fix.  Up to 7 or 8 is possible
Const GPS_MAX_ON_TIME As Long = 180 ' s                       ' If the GPS is on longer than this, the subroutine turns it off

Sub GPSOff
  Call WritePort(Vx2,0)                                       ' Turn off the power to the GPS and other internal status sensors
  Message = "GPS reading complete, turning off internal sensor power"
  Timer(GPS_TIMER,Sec,TIMER_STOP)
  GPSPowerStatus = False: ReadGPSNow = False                  ' And go back to waiting for the next request
EndSub

Sub ReadGPS
  If ReadGPSNow Then
    If NOT(GPSPowerStatus) Then                               ' If it wasn't previously on
      Message = "Powering GPS for location tracking. "
      Call WritePort(Vx2,True)                                ' Use WritePort first so it keeps track of the status of the port
      ExciteV(Vx2,5000,0)                                     ' Then set it to 5V which is higher than the 3.3V default
      GPSPowerStatus = True
      Timer(GPS_TIMER,Sec,TIMER_RESET_AND_START)              ' Start the GPS timer
    EndIf
    If (Timer(GPS_TIMER,Sec,TIMER_READ)>GPS_MAX_ON_TIME) Then
      Call GPSOff: Message = "GPS timer shutdown"
    EndIf
    SerialIn(RawGPSString,GPS_PORT,50,0,GPS_BUFFER)           ' Read in the serial data.  Termination is the time when characters stop being received (i.e. a break)
    SerialFlush(GPS_PORT)                                     ' Clear out any data so a fresh reading is taken next cycle
    GPSStart = InStr(1,RawGPSString,GPS_HEADER,2)             ' Find the position of $GPGGA (start).  Structure of $GPGGA is defined here: http://aprs.gids.nl/nmea/#gga
    GPSEnd = InStr(GPSStart+1,RawGPSString,"M",2)             ' Find the position of the terminator.  Normally this would be CRLF, but use an M which is the end of the meaningful data.  See http://aprs.gids.nl/nmea/#gga
    If (GPSStart>0) AND (GPSEnd>0) Then
      GPSString = Mid(RawGPSString,GPSStart,GPSEnd-GPSStart)  ' Get the part between the start and the end
      GPSLength = Len(GPSString)
      Comma2=1: CommaCount = 0                                ' Now parse the information and convert to double precision data, starting at the start of the string
      For InternalCounter = 1 To GPS_PARAMETERS
        Comma1 = InStr(Comma2,GPSString,",",2): Comma2 = InStr(Comma1+1,GPSString,",",2) ' Start searching at the position of the last comma
        If Comma2 > 0 Then
          GPSReadingsString(InternalCounter) = Mid(GPSString,Comma1+1,Comma2-Comma1-1) ' If it isn't above zero, the string was truncated for some reason
          CommaCount+=1
        EndIf
      Next InternalCounter
      For InternalCounter = 1 To GPS_PARAMETERS
        GPSReadings(InternalCounter) = GPSReadingsString(InternalCounter) ' Convert from string to double
      Next InternalCounter
      If CommaCount >= 9 AND (GPSReadings(7) >= GPSSatellitesRequired) Then ' We have enough satellites so save the information
        Latitude = Floor(GPS_Latitude_dddmm / 100.0) + (GPS_Latitude_dddmm MOD 100)/60
        Longitude = Floor(GPS_Longitude_dddmm / 100.0) + (GPS_Longitude_dddmm MOD 100)/60
        If GPSReadingsString(3) = "S" Then                    ' Add the sign to the latitude / longitude
          GPSReadings(3) = -1
          GPS_Latitude_dddmm = -GPS_Latitude_dddmm
          Latitude = -Latitude
        Else
          GPSReadings(3) = 1
        EndIf
        If GPSReadingsString(5) = "W" Then
          GPSReadings(5) = -1
          GPS_Longitude_dddmm = -GPS_Longitude_dddmm
          Longitude = -Longitude
        Else
          GPSReadings(5) = 1
        EndIf
        GPSFix = GPS_QualityIndicator
        UTCTime = GPS_UTCtime: UTCDate = 0: GPSSatellitesInView = GPS_Satellites ' UTCDate isn't part of serial message
        Message = "GPS location complete, using " + GPSReadings(7) + " satellites."
        Call GPSOff
      EndIf ' If we have a fix
    EndIf ' If we have a complete string
  EndIf ' If ReadGPSNow
EndSub ' ReadGPS

DataTable(Ai1,True,3000)                                      ' Records status information for remote diagnostics
  DataInterval(0,1,Hr,0)
  Sample(1,BatteryVoltage,FP2)
  Sample(1,InternalTemperature,FP2)
  Sample(1,InternalHumidity,FP2)
  Average(1,Current_mA,FP2,False): FieldNames("CurrentAverage:mA"): Units CurrentAverage = mA (-=Charge, +=Discharge) ' Can not use UINT2, must be FP2
  Maximum(1,Current_mA,FP2,False,False): FieldNames("CurrentMaximum:mA"): Units CurrentMaximum = mA (-=Charge, +=Discharge)
  Sample(1,SensorHoldPowerOn,Boolean)
  Sample(1,ProcessingTime,UINT2)
  Sample(1,Status.SerialNumber,UINT2)
  Sample(1,DataloggerOSVersion,FP2)
  Sample(1,Ai1OSVersion,FP2)
  Sample(1,Status.ProgSignature,UINT2): FieldNames("ProgramSignature:0-65535)"): Units ProgramSignature = (0-65535)' Store the program signature to know when a program has changed
  Sample(1,ProgramCounter,Long)
  Sample(1,Status.StartUpCode,FP2): FieldNames("StartUpCode:0=Ok,-1=Power Loss,-2=Watchdog"): Units StartUpCode = (0=Ok, -1=Power, -2=Watchdog)
  Sample(1,Status.WatchdogErrors,FP2): FieldNames("WatchdogErrors:Watchdog Errors Since Compile"): Units WatchdogErrors = Errors Since Compile
  Sample(1,Status.SkippedScan,FP2): FieldNames("SkippedScans:Scans Skipped"): Units SkippedScans = Scans Skipped
  Sample(1,Status.MemoryFree, UINT2): FieldNames("MemoryFree:Bytes"): Units MemoryFree = Bytes
  Sample(1,Status.CellUsageToday,FP2): FieldNames("CellUsageToday:kB"): Units CellUsageToday = kB
  Sample(1,Status.CellUsageMonth,Long): FieldNames("CellUsageThisMonth:kB"): Units CellUsageThisMonth = kB 
  Sample(1,Status.CellRSSI,FP2): FieldNames("CellRSSI:dBm"): Units CellRSSI = dBm ' 3G: Status.CellRSSI.  Excellent: Less than -70dBm, Good: -70dBm to -85dBm, Fair: -85dBm to -100dBm, Poor: Worse than -100dBm
  Sample(1,Status.CellNetBand,FP2): FieldNames("CellNetBand:band")
  Sample(1,Latitude,IEEE4)
  Sample(1,Longitude,IEEE4)
  Sample(1,GPSSatellitesInView,FP2)
  Sample(1,Pressure_mH2O,FP2)
  Maximum(1,ReadAttempts,UINT2,False,False)                   ' Record the maximum number of ReadAttempts this interval as most sensors are measured more frequently than the Ai1 table is stored
EndTable


Sub Initialization
  ValueToLoad = 0
  AddressToRead = 0 ' Stops a warning if not used
  Call GPSOff                                                 ' First time starting up, turn the GPS off to put the power output port and regulator in a known state
  SerialOpen(GPS_PORT,GPS_BAUD, 0, 0, GPS_BUFFER,ALLOW_SLEEP)    ' Open GPS port
  Message = "Initializing... "
  RealTime(rTime)
  Call ErrorLog("Program restart")                            ' Record the program restart in the error log
  Delay(0,500,mSec)                                           ' Have a short delay incase multiple messages are generated
  Control_____________ = false: Measurements________ = false: i = 0  ' Just to stop a compile warning that it is unused
  SetSetting("PakBusTCPClients", TCP_CLIENT)
  SetSetting("PakBusAddress", PAKBUS_ADDRESS)
  Battery(BatteryVoltage)                                     ' Get a battery voltage reading so that on first execution it will have a reading
  SetSetting("CellEnabled", True)                              ' Make sure that the modem is turned on
  SetSetting("CellAPN", AccessPointName)                       ' Configure the APN.  It is possible to set this through the constant table
  SetSetting("CellPwrStartTime", CELL_WINDOW_START)            ' When to power up the modem
  SetSetting("CellPwrDuration", CELL_WINDOW_DURATION)          ' How long is each window
  SetSetting("CellPwrRepeat", CELL_WINDOW_FREQUENCY)           ' When does the window repeat, i.e. hourly
  SetSetting("CellBillingDay", CellBillingDay)                 ' When to roll over the monthly usage
  SetSetting("CellKeepAlive", "www.google.com")                ' URL to ping to verify network connectivity.  If this fails, the datalogger will re-establish
  SetSetting("CellKeepAliveTime", 30)                          ' How often to ping test the link
  CommsPowerOnStatus = true: IPNetPower(5,1,0)                ' Make sure that it is turned on
	Call WritePort(Vx1,True)
  Call WritePort(SW12V,True)
	For i = 25 To 1 Step -1
	  Delay(0,1,Sec): Message = "Powering sonde (" + i + "s remaining)" ' Wait for sonde to power up
	Next i
	YSIPInit(): findSonde(3): Message = "Sonde initialized. "
	Call WritePort(Vx1,0)                                        ' Turn off RS485 adapter.  Don't check SensorKeepRS485On because this is during initialization
	If SENSOR_WARMUP_S > 0 Then Call WritePort(SW12V,0)          ' Unless sensor power is to be held on, switch off the sonde
  If Status.LithiumBattery < 3.0 Then                         ' Check diagnostics are record to ErrorLog if a problem
    Call ErrorLog("Low (or no) Lithium Battery = " + Status.LithiumBattery): Delay(0,500,mSec) ' Log with delay incase multiple messages are generated
  EndIf
  If Status.WatchdogErrors > 0 Then
    Call ErrorLog("Watchdog errors = " + Status.WatchdogErrors): Delay(0,500,mSec) ' Log with delay incase multiple messages are generated
  EndIf
  ' Check that all the measurement parameters are correct and evenly divisible (or measurements wont be taken correctly)
  If MEASUREMENT_INTERVAL_S MOD SCAN_INTERVAL_S > 0 Then Call ErrorLog("MEASUREMENT_INTERVAL_S (" + MEASUREMENT_INTERVAL_S + " sec) needs to be a multiple of SCAN_INTERVAL_S (" + SCAN_INTERVAL_S + " sec)")
  If SLOW_MEASUREMENT_INTERVAL_S MOD SCAN_INTERVAL_S > 0 Then Call ErrorLog("SLOW_MEASUREMENT_INTERVAL_S (" + SLOW_MEASUREMENT_INTERVAL_S + " sec) needs to be a multiple of SCAN_INTERVAL_S (" + SCAN_INTERVAL_S + " sec)")
  If DATA_STORAGE_INTERVAL_S MOD SCAN_INTERVAL_S > 0 Then Call ErrorLog("DATA_STORAGE_INTERVAL_S (" + DATA_STORAGE_INTERVAL_S + " sec) needs to be a multiple of SCAN_INTERVAL_S (" + SCAN_INTERVAL_S + " sec)")
  If SENSOR_WARMUP_S = 0 Then SensorProgramOn = True          ' Warmup = 0, means always on, start powered up
  If SENSOR_WARMUP_S MOD SCAN_INTERVAL_S > 0 Then Call ErrorLog("SENSOR_WARMUP_S (" + SENSOR_WARMUP_S + " sec) needs to be a multiple of SCAN_INTERVAL_S (" + SCAN_INTERVAL_S + " sec)")
  DataloggerOSVersion = Right(Status.OSVersion,5)             ' Get the OS version and convert to a string, only needed at startup.  5 characters works for OS > 10.01
  Message += "System initialization complete.": Call AddDate
EndSub


Sub SystemCheck
  If TimeIntoInterval(0,SLOW_MEASUREMENT_INTERVAL_S,sec) Then ReadStatusSensors = True
  PanelTemp(InternalTemperature,FILTER_FREQUENCY)             ' Measure each time as this is a surrogate indicator for analog errors - when it has noise in the data
  Battery(BatteryVoltage)                                     ' Measure using the CR300 battery voltage hardware
  If ReadStatusSensors Then
    ReadGPSNow = True                                         ' Set the flag to trigger GPS readings
    Call WritePort(Vx2,True)                                  ' Start with 3.3V for humidity. Must be 3V3 or the output will be above 2.5V for SE channel.  Have tested 5V sensor to read correctly at 3V3
    VoltSe(HumidityVoltage,1,mV2500,HUMIDITY_PORT,True,50000,FILTER_FREQUENCY,1.0,0)
    InternalHumidity = (((HumidityVoltage/3300)-0.1515)/0.0052)/(1.0546-0.00216*InternalTemperature)
    If InternalHumidity > 100 Then InternalHumidity = 100
    If InternalHumidity > 80 Then Message = "Change desiccant ASAP, condensation likely.  Ref: Ai1 manual seciton 22.":  Call AddTime: Errors = Message
    ExciteV(Vx2,5000,0)                                       ' Barometer uses 5V excitation
    For i = 1 To PRESSURE_READINGS
      VoltSe(PressureArray(i),1,mv2500,PRESSURE_PORT,True,2000,50,0.001,0) ' Measure the voltage of the barometric pressure sensor.  Sensor uses 5V excitation.  0.001 convert to volts
    Next i
    SortSpa (PressureArray(),PRESSURE_READINGS,PressureArray())
    Pressure_Voltage = PressureArray(Ceiling(PRESSURE_READINGS/2))
    If PressureFirstReading Then                              ' First time through the program fill the array with the initial value
      For i = 1 To PRESSURE_TIME_AVERAGING
        PressureTimeArray(i) = Pressure_Voltage
      Next i
      PressureFirstReading = False                            ' Only do this first time through
    Else
      For i = 1 To PRESSURE_TIME_AVERAGING - 1
        PressureTimeArray(i) = PressureTimeArray(i + 1)
      Next i
      PressureTimeArray(PRESSURE_TIME_AVERAGING) = Pressure_Voltage
    EndIf
    SortSpa( PressureTimeArraySorted(),PRESSURE_TIME_AVERAGING,PressureTimeArray())
    Pressure_Voltage = PressureTimeArraySorted(Ceiling(PRESSURE_TIME_AVERAGING/2))
	  Pressure_hPa = (0.725*Pressure_Voltage-0.2625)*1000
    Pressure_mH2O = (Pressure_hPa - 1013.25) * hPa_TO_m       ' Offset relative to standard atmospheric pressure
    Call WritePort(Vx2,True)
    ExciteV(Vx2,5000,0)                                       ' Step up to 5V for other internal sensors
    VoltSe(Current_mV,1,mv2500,CURRENT_PORT,True,0,FILTER_FREQUENCY,1,0) ' Read the raw mV output. Settling time is from humidity sensor
    Current_mA = (Current_mV - CURRENT_ZERO_mV) * 5           ' Normal output is 400mA/1000mV, or 2.5mV/mA, but with 2:1 voltage divider it is 5mV/mA
    ReadStatusSensors = False                                 ' GPS turns off internal sensor power at the completion of its measurement
  EndIf
  Call ReadGPS
  If BatteryVoltage < LOW_BATTERY_SHUTDOWN_V Then
    If ReadNow Then                                           ' If this is a brownout when making a reading, just display the error message so it isn't lost
      If(Left(Errors,17) <> Left("Low Battery Warning",17)) Then Call ErrorLog("Low Battery Warning, Brownout during measurement. " + BatteryVoltage + "V.  Note only" )
    Else                                                      ' But if it is not during a measurement then turn off the modem as well
      CommsPowerOnStatus = false: IPNetPower(5,0,0)
      If(Left(Errors,17) <> Left("Low Battery Shutdown",17)) Then Call ErrorLog("Low Battery Shutdown, Modem off. " + BatteryVoltage + "V.  Ref: Ai1_manual section 9.2" ) ' Only store is this is a new message
    EndIf
  Else
    If (BatteryVoltage < LOW_BATTERY_SAVER_V) AND ((Hour < 6) OR (Hour > 18)) Then
      If(Left(Errors,17) <> Left("Low Battery Saver",17)) Then Call ErrorLog("Low Battery Saver, Communications turned off overnight. " + BatteryVoltage + "V.  Ref: Ai1_manual section 9.2") ' Only store if this is a new message
      CommsPowerOnStatus = false: IPNetPower(5,0,0)
    Else  
      If CommsPowerOnStatus = false Then
        If ProgramCounter > LastProgramCounter + 10 Then      ' Only cycle power if not recently done
          Call ErrorLog("Battery power restored, resuming normal operation.  Ref: Ai1_manual section 9.2")
          CommsPowerOnStatus = true: IPNetPower(5,1,0)       ' Apply power to the modem
        EndIf
      EndIf
    EndIf
  EndIf
  CallTable Ai1
  ProgramCounter += 1                                         ' Increment the program counter
  ProcessingTime = Status.ProcessTime                         ' Processing time is used for checking that the program executes cleanly.  Should be last instruction
EndSub

Const HISTORY_RECORDS As Long = 3
Public ErrorHistory(HISTORY_RECORDS) As String * 96           ' Keep the recent messages available for review
Sub ErrorLog(ErrorMessage As String * 96)
  Errors = ErrorMessage + ". " + Public.Timestamp(2,1)
  For i = 1 To (HISTORY_RECORDS - 1)
    ErrorHistory(i) = ErrorHistory(i+1)
  Next i
  ErrorHistory(HISTORY_RECORDS) = Errors
  LastProgramCounter = ProgramCounter                         ' Keep track of the program counter when this occured
EndSub


Sub LoadData ' Names but be spelled correctly
  ParameterToSend(1) = @ExternalTemp
  ParameterToSend(2) = @SpConductivity_us
  ParameterToSend(3) = @Pressure_abs
  ParameterToSend(4) = @Chlorophyll_ugL
  ParameterToSend(5) = @Chlorophyll_RFU
  ParameterToSend(6) = @BGA_PC_ugL
  ParameterToSend(7) = @BGA_PC_RFU
  ParameterToSend(8) = @BatteryVoltage
  ParameterToSend(9) = @InternalHumidity
  ParameterToSend(10) = @Latitude
  ParameterToSend(11) = @Longitude
  ' ParameterToSend(4) = @Turbidity
  ' ParameterToSend(5) = @ODO
  ' ParameterToSend(6) = @ODO_Sat
  ' ParameterToSend(7) = @pH
  ' ParameterToSend(8) = @pH_mV
EndSub

BeginProg
  Call Initialization
  Scan (SCAN_INTERVAL_S,Sec,0,0)
    ' Add any other custom sensor measurements here
    Call SensorMeasurements
    ' Add any other communications or control instructions here
  NextScan

  SlowSequence                                                ' System background checks in a separate sequence so it does not slow down other functions
    Scan (SCAN_INTERVAL_S,Sec,0,0)
      Call SystemCheck
    NextScan
  EndSequence

  SlowSequence                                                ' Communications management in a separate sequence so it does not slow down other functions
    Scan (SCAN_INTERVAL_S,Sec,0,0)
      ' Any other time specific instructions should go before the communications subroutine
      Call Communications
    NextScan
  EndSequence
EndProg
