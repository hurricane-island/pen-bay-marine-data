StationName = $STATION_NAME ' No quotes!
Const HYDROSPHERE_ID = "$CLIENT_ID" ' Hydrosphere site.
Const PAKBUS_ADDRESS As Long = $PAKBUS_ADDRESS ' network address
Const TCP_CLIENT As String = "(drema.konectgds.com,9200)" ' Pakbus Router
Public AccessPointName As String = "so01.VZWSTATIC" ' Cell APN
Const PARAMETERS_TO_SEND = 14 ' message width for cloud
Const HYDROSPHERE_BUFFER_SIZE As Long = 96 ' 96 is required for 15min data, for 12 hours - if daily updates are used

' Const CELLULAR As Long = 1
Const SDI12 As Long = 1
Const RS232 As Long = 2
Const ANALOG As Long = 3
Const RS485 As Long = 4
Const ABSOLUTE As Long = 1
' Const DIFFERENTIAL As Long = 2
Public Errors As String * 128 = ""
Public Message As String * 256 = ""
' Public PortsStatus As String * 90
Dim PortsON As Long = 0
Const SCAN_INTERVAL_S As Long = 5 ' Program scan Interval.
Const MEASUREMENT_INTERVAL_S As Long = 600 ' Sensor measurement interval
Const SLOW_MEASUREMENT_INTERVAL_S As Long = 300 ' interval for less critical measurements, such as GPS
Const DATA_STORAGE_INTERVAL_S As Long = 600 ' Store data every measurement cycle
Const LOW_BATTERY_SAVER_V = 12.83
Const LOW_BATTERY_SHUTDOWN_V = 12.75' V  ' Battery protection thresholds.
' Const COMMS As Long = CELLULAR
Const CELL_WINDOW_START As Long = 1440
Const CELL_WINDOW_DURATION As Long = 10
Const CELL_WINDOW_FREQUENCY As Long = 1440  ' Modem is always on when CELL_WINDOW_START = 1440
Const CURRENT_ZERO_mV As Long = 1250 ' mV.To recalibrate: Remove fuse and power Ai1 from charging input, measure Current_mV
Const A3_RATIO As Float = 1.000 ' Factory calibrated.  2:1 voltage divider fitted on A3
Const SENSOR_QTY As Long = 1  ' Number of sensors fitted to this station, repeat the measurements on sequential ports or address
' Const GPS_INTERFACE As Long = RS232
Const TABLE_WQ As Long = 200000
Const SONDE_USED As Boolean = TRUE
Const SONDE_USES_RS485 As Boolean = True
Const SONDEVALUES_TBL_SIZE As Long = 5000
Const PRESSURE_TYPE As Long = ABSOLUTE
Const PRESSURE_FSR_PSI As Float = 43.5
Const TRANSFER As Float = 0.1 ' Pressure sensor configuration
Const PRESSURE_PORT As Long = 3
Const PRESSURE_INTERFACE As Long = ANALOG
Const SENSOR_POWER_PORT As Long = SW12V
Const GPS_PORT As Long = ComC2_Rx
Const YSIPPORT As Long = ComRS232
Public Ai1WipesSonde As Boolean = True
PreserveOneVariable(Ai1WipesSonde)
Dim ParameterToSend(PARAMETERS_TO_SEND) As Long ' points to the address of each variable to send
Public ExternalTemp As Float ' First reading from the sonde, use this instead of External_Temp

' Caution editing above here'
Include "CPU:YSIP_CONST_Enc.CR300"
Include "CPU:YSIP_CORE_Enc.CR300"
' OK to edit below here'

Dim Ai1OSVersion As Float = 0.75
Dim DataloggerOSVersion As Float ' Used for holding CR300 OS version
Const FILTER_FREQUENCY As Long = 4000 ' Set to 50 or 60 for situations with AC noise, otherwise 4000Hz provides quickest processing
Const TIMER_STOP As Long = 1
Const TIMER_RESET_AND_START As Long = 2
Const TIMER_READ As Long = 4
Const ALLOW_SLEEP As Long = 1
Const GPS_TIMER As Long = 11
Const CR = CHR(13)
Const hPa_TO_m As Float = 0.0101972
Const CURRENT_PORT As Long = 5
Const HUMIDITY_PORT As Long = 6
Const READ_ATTEMPTS_LIMIT As Long = 4
Public ReadAttempts As Long ' Times sensor read was attempted
Dim ProgramCounter As Long: Units ProgramCounter = Cycles ' Program cycles since power up
Dim LastProgramCounter As Long: Units LastProgramCounter = Cycles ' Error tracking
Public BatteryVoltage As Float: Units BatteryVoltage = Volts
Dim Vx1Voltage As Long
Dim Vx2Voltage As Long ' Keep track of the excitation port voltage so that it can safely be turned off after status readings 
Const PRESSURE_PARAMETERS As Long = 3
Public Pressure(PRESSURE_PARAMETERS) As Float
Alias Pressure(1) = Pressure_Voltage: Units Pressure_Voltage = Volts
Alias Pressure(2) = Pressure_hPa: Units Pressure_hPa = hPa
Alias Pressure(3) = Pressure_mH2O: Units Pressure_mH2O = mH2O
Const PRESSURE_READINGS As Long = 7 ' Number of measurements to take from averaging this single reading
Const PRESSURE_TIME_AVERAGING As Long = 5 ' Time averaging of pressure readings
Dim PressureArray(PRESSURE_READINGS) As Float ' Array to hold readings from which the median value is used
Dim PressureTimeArray(PRESSURE_TIME_AVERAGING) As Float ' Array to hold the time series of median filtered readings
Dim PressureTimeArraySorted(PRESSURE_TIME_AVERAGING) ' To hold the sorted values for median selection
Dim PressureFirstReading As Boolean = True ' First time through, copy the initial value to all elements in array
Public Current_mA As Long: Units Current_mA = mA ' Use long so that only whole numbers are returned
Dim Current_mV As Float: Units Current_mV = mV
Public InternalTemperature As Float: Units InternalTemperature = °C
Public InternalHumidity As Long: Units InternalHumidity = % ' Report only whole numbers
Public HumidityVoltage As Float: Units HumidityVoltage = mV
Public ProcessingTime: Units ProcessingTime = µS
Dim rTime(9)
Alias rTime(1) = Year
Alias rTime(2) = Month
Alias rTime(3) = DayOfMonth
Alias rTime(4) = Hour
Alias rTime(5) = Minute
Alias rTime(6) = Second
Alias rTime(7) = uSecond
Dim i As Long ' For internal counters only
Dim AddressToRead As Long ' Used by several subroutines, for holding a memory address for a pointer
Dim ValueToLoad As Float ' Internal processing only, the value at the pointer address in Float form

Sub AddTime ' Adds time onto end of message, formatted to H:MM:SS
  Message += Hour + ":"
  If Minute < 10 Then Message += "0" 
  Message += Minute + ":"
  If Second < 10 Then Message += "0"
  Message += Second
EndSub

Sub AddDate
  Message += ", " + DayOfMonth + "/" + Month + "/" + Year + "."
EndSub 


Sub WritePort(PortToWrite As Long, StateToWrite As Boolean)
  ' Fixes the problem with PortSet which can not run in conditional loops, call with PortToWrite as C1/C2/SE1/SE2/SE3/SE4/SW12V/Vx1/Vx2
  Dim StateMask As Long = 0
  Select Case PortToWrite  
  Case SW12V  ' This equates to 7
    If StateToWrite Then StateMask = &B01000000 Else StateMask = 0
    Message = "Setting SW12V to ": If StateToWrite Then Message += "ON (12V)" Else Message += "OFF"
    WriteIO(&B01000000, StateMask)
  Case Vx1 ' Vx1/Vx2 do not use WriteIO, it must set to the desired state
    If StateToWrite Then Vx1Voltage = 5000 Else Vx1Voltage = 0 ' Vx1 is either 5V or 0V
    Message = "Setting Vx1 to " + (Vx1Voltage/1000) + "V"
    ExciteV(Vx1, Vx1Voltage, 0) 
  Case Vx2 ' Vx2 has high power regulator as well.  Due to enable/disable circuit Vx2 can not be fully turned off. Anything >400mV is accurate.  
    If StateToWrite Then Vx2Voltage = 3300 Else Vx2Voltage = 0 ' Vx2 is either 3.3V or 0V
    Message = "Setting Vx2 to " + (Vx2Voltage/1000) + "V"
    ExciteV(Vx2, Vx2Voltage, 0)
  Case Else
    Call ErrorLog("Port not recognized.  Port: " + PortToWrite + ", State: " + StateToWrite) ' Write to errors so this doesn't disappear
  EndSelect
  Message += ". "
  Call AddTime
  Message +=". "
EndSub


Dim CommsPowerOnStatus As Boolean = True
Dim CellBillingDay = 1 ' Day of Month
Public Control_____________ As Boolean = False ' This groups all the program control flags into one section for ease of use
Dim ReadGPSNow As Boolean = False: Units ReadGPSNow = True = Trigger a new GPS reading ' Set by setting ReadStatusSensors true

Public ReadNow As Boolean = False: Units ReadNow = True = Trigger A New Sensor Reading
Public ReadStatusSensors As Boolean = False
Public SensorKeepRS485On As Boolean = False ' Set true if power is to be kept on between readings.  May be useful to see the full boot-up message from the sonde.  No, it stops this working at all.  Only get a couple of bytes, 00 FF
Dim SensorKeepRS485OnLast As Boolean = False                  ' Keep track of when this is first turned on, so you can power up the adapter
Dim SensorProgramOn As Boolean = False
Dim SensorProgramOff As Boolean = False ' Program controlled power operation 
Public Measurements________ As Boolean = False
Dim SensorPowerStatus: Units SensorPowerStatus = Returns True If Sensor Is ON
Public GPSPowerStatus As Boolean: Units GPSPowerStatus = Returns True If GPS Is ON
Const GPS_BAUD As Long = 9600
Const GPS_BUFFER As Long = 512 ' The uBlox GPS output

Public SondeReadFailed As Boolean = False
Dim WQTemporaryRS485(YSISWATH) As Float ' A temporary array to be used to hold returned values prior to confirming as valid
Alias SondeValuesSorted(45) = Sonde_Future1
Alias SondeValuesSorted(46) = Sonde_Future2
Alias SondeValuesSorted(47) = Sonde_Future3
Alias SondeValuesSorted(48) = Sonde_Future4
Alias SondeValuesSorted(49) = Sonde_Future5
Alias SondeValuesSorted(50) = Sonde_Future6
Alias SondeValuesSorted(51) = Sonde_Future7
Alias SondeValuesSorted(52) = Sonde_Future8
Alias SondeValuesSorted(53) = Sonde_Future9
Alias SondeValuesSorted(54) = Sonde_Future10
Alias SondeValuesSorted(55) = Sonde_Future11
Alias SondeValuesSorted(56) = Sonde_Future12
Alias SondeValuesSorted(57) = Sonde_Future13
Alias SondeValuesSorted(58) = Sonde_Future14
Alias SondeValuesSorted(59) = Sonde_Future15
Alias SondeValuesSorted(60) = Sonde_Future16

Sub MeasureWaterQuality
  Message = "Powering RS485 adapter for communications"
  Call WritePort(Vx1, True) ' Turn on the RS485 adapter
  Delay(0, 200, mSec) ' Short delay to allow sonde to wake up
  WQTemporaryRS485() = SondeValuesSorted() ' Save previous values
  If NOT sondefound Then findSonde(3) ' If the sonde hasn't been found, then attempt to find first
  If Ai1WipesSonde Then ' When using Sample&Hold in the sonde, the sonde controls the wiping frequency, no need to duplicate here
    Message = "Allowing time for sonde wiper."
    startWipe() ' full wipe is 2 in each direction, takes approximately 22-25s
    getWipeStatus()
    For i = 40 To 1 Step -1
      Delay(0, 1, Sec)
      Message = "Allowing time for sonde wiper (" + i + "s remaining)"
    Next i
  EndIf
  Message = "Reading sonde and updating available parameters. "
  sondeCheck()
  getSondeParams() ' Handle any sonde changes and update parameters
  ReadAttempts = 0
  Do
    ReadAttempts += 1
    Message = "Reading sonde values, attempt " + ReadAttempts
    Sonde_External_Voltage = NaN
    External_Temp = NaN
    Depth = NaN ' Prepare parameters to check with NaN so that a successful read is identified
    getSondeValues() ' Populate available parameters
    sortYSIPData()
    ExternalTemp = External_Temp ' Map the temperature reading so that Hydrosphere and Satellite naming will work
    SondeReadFailed = False
    If (Sonde_External_Voltage = NaN) AND (WiperPosition = NAN) Then SondeReadFailed = True ' NAN's occur if there is no communications to sonde
    If (Sonde_External_Voltage = 0) AND (WiperPosition = 0) Then SondeReadFailed = True ' 0's can occur if the sonde has failed to measure sensors yet, but ready to talk
  Loop While (SondeReadFailed AND (ReadAttempts <= READ_ATTEMPTS_LIMIT)) ' Repeat if the read failed (any non-NaN value will mark success)
  If SondeReadFailed Then ' Restore the previous values
    SondeValuesSorted() = WQTemporaryRS485()
    Message = "No valid Data ("
    If Sonde_External_Voltage = NaN Then 
      Message += "NAN returned"
    ElseIf Sonde_External_Voltage = 0 Then Message += "Zero's returned"
      Message += "Unspecified response"
    EndIf
    Message += "), restoring previous values. "
    Call AddTime
    Call AddDate
    Errors = Message ' Message only, not logged
  Else
    Message = "Sonde read completed"
    getSondeSN()
    CallTable SondeValues ' Only store if successful
  EndIf
  CallTable YSISondeMeta
  If SensorKeepRS485On Then
    Message += ".  Keeping RS485 powered on (override by SensorKeepRS485On)" ' Set by program control for testing.  High power.
  Else
    Message += ".  Shutting down RS485 adapter"
    Call WritePort(Vx1, False) ' sonde in lower power state
  EndIf
EndSub

Public Queue(HYDROSPHERE_BUFFER_SIZE) As String *(22+PARAMETERS_TO_SEND*10)
Public Labels As String *(PARAMETERS_TO_SEND*26)
Dim NextRecord As Long = 1
Dim HydrosphereDescription(PARAMETERS_TO_SEND) As String * 26 ' up to 24 characters
Dim HydrosphereValues(PARAMETERS_TO_SEND) As Float ' values to send

Sub Hydrosphere
  Dim Socket As Long
  Dim Output As Long
  Dim Attempts = 0
  Dim MaxRetries = 5
  Dim Timeout = 500 ' x 0.01s

  If NextRecord > 1 Then
    Do While NextRecord > 1 AND Attempts < MaxRetries
      Attempts += 1
      Socket = TCPOpen("stormcentral.waterlog.com", 32212, 1000, Timeout)
      If Socket <> 0 Then
        SerialFlush(Socket)
        SerialOut(Socket, "SL(" + HYDROSPHERE_ID + ")" + CR, "OK", 1, Timeout)
        SerialOut(Socket, Labels, "OK", 1, Timeout)
        Output = SerialOut(Socket, Queue(1), "OK", 1, Timeout)
        SerialOut(Socket, "DIS" + CR, "OK", 1, Timeout)
        TCPClose(Socket)
      Else
        Message = "No connection"
        Output = 0 ' Make sure that the last OK is not still in the status
      EndIf
      If Output = 2 Then ' If "OK" was sent
        If NextRecord > 2 Then ' If we have at least 2 values, shift left.
          For i = 1 To (NextRecord - 2)
            Queue(i) = Queue(i+1)
          Next i
        EndIf
        NextRecord -= 1
        Queue(NextRecord) = "" ' Clear buffer
        Message = "Report " + NextRecord + " sent"
      ElseIf Attempts = MaxRetries Then 
        Message = "Tx failed after " + Attempts + " attempts"
      Else
        Message = "No OK (" + Output + "). Retrying..."
      EndIf
    Loop
  Else
    Message = "No data to send"
  EndIf

  RealTime(rTime) ' Update timestamp
  Message += ". "
  Call AddTime
  Message += "."
EndSub


Const GPS_PARAMETERS As Long = 9 ' 1=Time(UTC),2=Date,3=Lat(ddmm),4=Lat(.mmmmmm),5=Long(ddmm),6=Long(.mmmmmm),7=Alt,8=Fix,9=#Sat
Dim GPSReadings(GPS_PARAMETERS) As Float
Public GPSString As String * GPS_BUFFER: Units GPSString = NMEA 0183 Processed String
Const GPS_HEADER As String = "$GPGGA" ' This is the header of the GPS string
Dim CommaCount As Long ' Use to make sure I have enough data
Dim GPSReadingsString(GPS_PARAMETERS) As String * 16
Dim RawGPSString As String * GPS_BUFFER: Units RawGPSString = NMEA 0183 String buffer
Dim GPSStart As Long: Units GPSStart = Start character For NMEA Message
Dim GPSEnd As Long: Units GPSEnd = End character For NMEA Message
Dim GPSLength As Long: Units GPSLength = characters in NMEA Message
Dim Comma1 As Long
Dim Comma2 As Long
Dim InternalCounter As Long
Alias GPSReadings(1) = GPS_UTCtime: Units GPS_UTCtime = HHMMSS
Alias GPSReadings(2) = GPS_Latitude_dddmm: Units GPS_Latitude_dddmm = dddmm.mmmm
Alias GPSReadings(3) = GPS_LatitudeHemisphere: Units GPS_LatitudeHemisphere = 1=N, -1=S
Alias GPSReadings(4) = GPS_Longitude_dddmm: Units GPS_Longitude_dddmm = dddmm.mmmm
Alias GPSReadings(5) = GPS_LongitudeHemisphere: Units GPS_LongitudeHemisphere = 1=E, -1=W
Alias GPSReadings(6) = GPS_QualityIndicator: Units GPS_QualityIndicator = 0=NoFix,1=GPS,2=DIFFERENTIAL
Alias GPSReadings(7) = GPS_Satellites: Units GPS_Satellites = count
Alias GPSReadings(8) = GPS_HDOP: Units GPS_HDOP = error estimate
Alias GPSReadings(9) = GPS_Height: Units GPS_Height = meters
Public Latitude As Float: Units Latitude = Decimal Degrees (N=+,S=-)  ' Latitude recombined into a single value.  These are what are stored in the data tables
Public Longitude As Float: Units Longitude = Decimal Degrees (E=+,W=-)
Public UTCTime As Long: Units UTCTime = HHMMSS
Dim UTCDate As Long: Units UTCDate = YYMMDD
Dim GPSFix As Long: Units GPSFix = 0=No FIX, 1=FIX, 2=DIFFERENTIAL FIX
Public GPSSatellitesInView As Long: Units GPSSatellitesInView = GPS Satellites visible
PreserveOneVariable(Latitude)
PreserveOneVariable(Longitude) ' Save these values so a power cycle does not reset them and cause the icon to jump around
Public GPSSatellitesRequired As Long = 4
PreserveOneVariable(GPSSatellitesRequired) ' Specifies the required satellites for an accurate GPS fix.  Up to 7 or 8 is possible
Const GPS_MAX_ON_TIME As Long = 180 ' turns off this many seconds

Sub GPSOff
  Call WritePort(Vx2, 0) ' Turn off the power to the GPS and other internal status sensors
  Message = "GPS reading complete, turning off internal sensor power"
  Timer(GPS_TIMER, Sec, TIMER_STOP)
  GPSPowerStatus = False
  ReadGPSNow = False ' And go back to waiting for the next request
EndSub

Sub ReadGPS
  If ReadGPSNow Then
    If NOT(GPSPowerStatus) Then                               ' If it wasn't previously on
      Message = "Powering GPS for location tracking. "
      Call WritePort(Vx2, True) ' Use WritePort first so it keeps track of the status of the port
      ExciteV(Vx2, 5000, 0) ' Then set it to 5V which is higher than the 3.3V default
      GPSPowerStatus = True
      Timer(GPS_TIMER, Sec, TIMER_RESET_AND_START)              ' Start the GPS timer
    EndIf
    If (Timer(GPS_TIMER, Sec, TIMER_READ) > GPS_MAX_ON_TIME) Then
      Call GPSOff
      Message = "GPS timer shutdown"
    EndIf
    SerialIn(RawGPSString, GPS_PORT, 50, 0, GPS_BUFFER) ' Read in the serial data.  Termination is the time when characters stop being received (i.e. a break)
    SerialFlush(GPS_PORT) ' Clear out any data so a fresh reading is taken next cycle
    GPSStart = InStr(1, RawGPSString, GPS_HEADER, 2) ' position of $GPGGA (start).
    GPSEnd = InStr(GPSStart+1, RawGPSString, "M", 2) ' position of the terminator.
    If (GPSStart>0) AND (GPSEnd>0) Then
      GPSString = Mid(RawGPSString,GPSStart,GPSEnd-GPSStart)  ' Get the part between the start and the end
      GPSLength = Len(GPSString)
      Comma2 = 1
      CommaCount = 0 ' Now parse the information and convert to double precision data, starting at the start of the string
      For InternalCounter = 1 To GPS_PARAMETERS
        Comma1 = InStr(Comma2, GPSString, ",", 2)
        Comma2 = InStr(Comma1+1, GPSString, ",", 2) ' Start searching at the position of the last comma
        If Comma2 > 0 Then
          GPSReadingsString(InternalCounter) = Mid(GPSString,Comma1+1,Comma2-Comma1-1) ' If it isn't above zero, the string was truncated for some reason
          CommaCount+=1
        EndIf
      Next InternalCounter
      For InternalCounter = 1 To GPS_PARAMETERS
        GPSReadings(InternalCounter) = GPSReadingsString(InternalCounter) ' Convert from string to double
      Next InternalCounter
      If CommaCount >= 9 AND (GPSReadings(7) >= GPSSatellitesRequired) Then ' We have enough satellites so save the information
        Latitude = Floor(GPS_Latitude_dddmm / 100.0) + (GPS_Latitude_dddmm MOD 100)/60
        Longitude = Floor(GPS_Longitude_dddmm / 100.0) + (GPS_Longitude_dddmm MOD 100)/60
        If GPSReadingsString(3) = "S" Then ' Add the sign to the latitude / longitude
          GPSReadings(3) = -1
          GPS_Latitude_dddmm = -GPS_Latitude_dddmm
          Latitude = -Latitude
        Else
          GPSReadings(3) = 1
        EndIf
        If GPSReadingsString(5) = "W" Then
          GPSReadings(5) = -1
          GPS_Longitude_dddmm = -GPS_Longitude_dddmm
          Longitude = -Longitude
        Else
          GPSReadings(5) = 1
        EndIf
        GPSFix = GPS_QualityIndicator
        UTCTime = GPS_UTCtime
        UTCDate = 0
        GPSSatellitesInView = GPS_Satellites ' UTCDate isn't part of serial message
        Message = "GPS location complete, using " + GPSReadings(7) + " satellites."
        Call GPSOff
      EndIf
    EndIf
  EndIf
EndSub

DataTable(Ai1, True, 3000) ' Records status information for remote diagnostics
  DataInterval(0, SLOW_MEASUREMENT_INTERVAL_S, Sec, 0)
  Sample(1, BatteryVoltage, FP2)
  Sample(1, InternalTemperature, FP2)
  Sample(1, InternalHumidity, FP2)
  Average(1, Current_mA, FP2, False): FieldNames("CurrentAverage:mA"): Units CurrentAverage = mA (-=Charge, +=Discharge)
  Maximum(1, Current_mA,FP2, False, False): FieldNames("CurrentMaximum:mA"): Units CurrentMaximum = mA (-=Charge, +=Discharge)
  Sample(1, ProcessingTime, UINT2)
  Sample(1, Status.SerialNumber, UINT2)
  Sample(1, DataloggerOSVersion, FP2)
  Sample(1, Ai1OSVersion, FP2)
  Sample(1, Status.ProgSignature, UINT2): FieldNames("ProgramSignature:0-65535)"): Units ProgramSignature = (0-65535)
  Sample(1, ProgramCounter, Long)
  Sample(1, Status.StartUpCode, FP2): FieldNames("StartUpCode:0=Ok,-1=Power Loss,-2=Watchdog"): Units StartUpCode = (0=Ok, -1=Power, -2=Watchdog)
  Sample(1, Status.WatchdogErrors, FP2): FieldNames("WatchdogErrors:Watchdog Errors Since Compile"): Units WatchdogErrors = Errors Since Compile
  Sample(1, Status.SkippedScan, FP2): FieldNames("SkippedScans:Scans Skipped"): Units SkippedScans = Scans Skipped
  Sample(1, Status.MemoryFree, UINT2): FieldNames("MemoryFree:Bytes"): Units MemoryFree = Bytes
  Sample(1, Status.CellUsageToday, FP2): FieldNames("CellUsageToday:kB"): Units CellUsageToday = kB
  Sample(1, Status.CellUsageMonth, Long): FieldNames("CellUsageThisMonth:kB"): Units CellUsageThisMonth = kB 
  Sample(1, Status.CellRSSI, FP2): FieldNames("CellRSSI:dBm"): Units CellRSSI = dBm
  Sample(1, Status.CellNetBand, FP2): FieldNames("CellNetBand:band")
  Sample(1, Latitude, IEEE4)
  Sample(1, Longitude, IEEE4)
  Sample(1, GPSSatellitesInView, FP2)
  Sample(1, Pressure_mH2O, FP2)
  Maximum(1, ReadAttempts, UINT2, False, False)
EndTable


Sub Initialization
  ValueToLoad = 0
  AddressToRead = 0 ' Stops a warning if not used
  Call GPSOff ' turn the GPS off to put the power output port and regulator in a known state
  SerialOpen(GPS_PORT, GPS_BAUD, 0, 0, GPS_BUFFER, ALLOW_SLEEP)
  Message = "Initializing... "
  RealTime(rTime)
  Call ErrorLog("Program restart") ' Record the program restart in the error log
  Delay(0, 500, mSec) ' Have a short delay incase multiple messages are generated
  Control_____________ = false
  Measurements________ = false
  i = 0  ' Just to stop a compile warning that it is unused
  SetSetting("PakBusTCPClients", TCP_CLIENT)
  SetSetting("PakBusAddress", PAKBUS_ADDRESS)
  Battery(BatteryVoltage) ' Get a battery voltage reading so that on first execution it will have a reading
  SetSetting("CellEnabled", True) ' Make sure that the modem is turned on
  SetSetting("CellAPN", AccessPointName) ' Configure the APN.  It is possible to set this through the constant table
  SetSetting("CellPwrStartTime", CELL_WINDOW_START) ' When to power up the modem
  SetSetting("CellPwrDuration", CELL_WINDOW_DURATION) ' How long is each window
  SetSetting("CellPwrRepeat", CELL_WINDOW_FREQUENCY) ' When does the window repeat, i.e. hourly
  SetSetting("CellBillingDay", CellBillingDay) ' When to roll over the monthly usage
  SetSetting("CellKeepAlive", "www.google.com") ' verify network connectivity.  If this fails, the datalogger will re-establish
  SetSetting("CellKeepAliveTime", 30) ' How often to ping test the link
  CommsPowerOnStatus = true
  IPNetPower(5, 1, 0) ' Make sure modem is turned on
  Call WritePort(Vx1, True)
  Call WritePort(SW12V, True)
  For i = 25 To 1 Step -1
    Delay(0, 1, Sec)
    Message = "Powering sonde (" + i + "s remaining)" ' Wait for sonde to power up
  Next i
  YSIPInit()
  findSonde(3)
  Message = "Sonde initialized. "
  Call WritePort(Vx1, 0) ' Turn off RS485 adapter.  Don't check SensorKeepRS485On because this is during initialization
  If Status.LithiumBattery < 3.0 Then ' Check diagnostics are record to ErrorLog if a problem
    Call ErrorLog("Low (or no) Lithium Battery = " + Status.LithiumBattery)
    Delay(0, 500, mSec) ' Log with delay incase multiple messages are generated
  EndIf
  If Status.WatchdogErrors > 0 Then
    Call ErrorLog("Watchdog errors = " + Status.WatchdogErrors)
    Delay(0, 500, mSec) ' Log with delay incase multiple messages are generated
  EndIf
  ' Check that all the measurement parameters are correct and evenly divisible (or measurements wont be taken correctly)
  If MEASUREMENT_INTERVAL_S MOD SCAN_INTERVAL_S > 0 Then Call ErrorLog("MEASUREMENT_INTERVAL_S (" + MEASUREMENT_INTERVAL_S + " sec) needs to be a multiple of SCAN_INTERVAL_S (" + SCAN_INTERVAL_S + " sec)")
  If SLOW_MEASUREMENT_INTERVAL_S MOD SCAN_INTERVAL_S > 0 Then Call ErrorLog("SLOW_MEASUREMENT_INTERVAL_S (" + SLOW_MEASUREMENT_INTERVAL_S + " sec) needs to be a multiple of SCAN_INTERVAL_S (" + SCAN_INTERVAL_S + " sec)")
  If DATA_STORAGE_INTERVAL_S MOD SCAN_INTERVAL_S > 0 Then
    Call ErrorLog("DATA_STORAGE_INTERVAL_S (" + DATA_STORAGE_INTERVAL_S + " sec) needs to be a multiple of SCAN_INTERVAL_S (" + SCAN_INTERVAL_S + " sec)")
  EndIf
  SensorProgramOn = True ' Warmup = 0, means always on, start powered up
  DataloggerOSVersion = Right(Status.OSVersion, 5) ' Get the OS version and convert to a string, only needed at startup.  5 characters works for OS > 10.01
  Message += "System initialization complete."
  Call AddDate
EndSub


Sub SensorMeasurements ' Time commands at the top, so slow commands don't interfere

  Public HydrosphereData As String *(22+PARAMETERS_TO_SEND*10) ' The string repr of one full record
  If TimeIntoInterval(0, MEASUREMENT_INTERVAL_S, Sec) Then 
    ReadNow = True
    SensorProgramOn = True ' always on
  EndIf
  If (SensorProgramOn) Then
    ' Turn on if instructed by either the user or the program. Turning off is after the measurement
    If NOT (SensorPowerStatus) Then ' Only turn it on if it is not already
      Call WritePort(SENSOR_POWER_PORT, True)
      SensorPowerStatus = True
    EndIf
    SensorProgramOn = false ' Only do this once
  EndIf
  If (ReadNow) Then
    Call MeasureWaterQuality
    ReadNow = false
  EndIf

  If TimeIntoInterval(0, DATA_STORAGE_INTERVAL_S, Sec) Then ' store at interval
    ' does not store data with RS485 sondes, must take measurements first, and measurements must be valid or CallTable is skipped (see above)
    ParameterToSend(1) = @ExternalTemp
    ParameterToSend(2) = @SpConductivity_us
    ParameterToSend(3) = @Pressure_abs
    ParameterToSend(4) = @Chlorophyll_ugL
    ParameterToSend(5) = @Chlorophyll_RFU
    ParameterToSend(6) = @BGA_PE_ugL
    ParameterToSend(7) = @BGA_PE_RFU
    ParameterToSend(8) = @BatteryVoltage
    ParameterToSend(9) = @InternalHumidity
    ParameterToSend(10) = @Salinity
    ParameterToSend(11) = @ODO
    ParameterToSend(12) = @ODO_Sat
    ParameterToSend(13) = @Latitude
    ParameterToSend(14) = @Longitude
 
    For i = 1 To PARAMETERS_TO_SEND
      HydrosphereDescription(i) = !(ParameterToSend(i)) ' name of memory location is the canonical vendor name
      AddressToRead = (ParameterToSend(i)) ' Cannot read the value directly
      HydrosphereValues(i) = !AddressToRead
    Next i
    RealTime(rTime)
    HydrosphereData = "D=" + FormatFloat(Month,"%02.0f") + "/" + FormatFloat(DayOfMonth,"%02.0f") + "/" + FormatFloat((Year MOD 100),"%02.0f") + "," + FormatFloat(Hour,"%02.0f") + ":" + FormatFloat(Minute,"%02.0f") + ":" + FormatFloat(Second,"%02.0f") + ","
    Labels = "SN="
    For i = 1 To PARAMETERS_TO_SEND
      Labels += HydrosphereDescription(i)
      HydrosphereData += HydrosphereValues(i)
      If i < PARAMETERS_TO_SEND Then 
        HydrosphereData += ","
        Labels += ","
      EndIf
    Next i
    If NextRecord <= HYDROSPHERE_BUFFER_SIZE Then
      Queue(NextRecord) = HydrosphereData + CR
      NextRecord += 1
    EndIf
  EndIf
  If (SensorProgramOff) Then
    If SensorPowerStatus Then ' Only turn off if currently on
      Call WritePort(SENSOR_POWER_PORT, False)
      SensorPowerStatus = False
    EndIf
    SensorProgramOff = False ' Only do this once
  EndIf
  If SensorKeepRS485On AND NOT(SensorKeepRS485OnLast) Then
    Message = "Turning on RS485 adapter based on SensorKeepRS485On setting"
    Call WritePort(Vx1, True)
  EndIf
  If NOT(SensorKeepRS485On) AND SensorKeepRS485OnLast Then
    Message = "Turning off RS485 adapter based on SensorKeepRS485On setting"
    Call WritePort(Vx1, False)
  EndIf
  SensorKeepRS485OnLast = SensorKeepRS485On
EndSub


Sub SystemCheck
  If TimeIntoInterval(0, SLOW_MEASUREMENT_INTERVAL_S, sec) Then
    ReadStatusSensors = True
  EndIf
  PanelTemp(InternalTemperature, FILTER_FREQUENCY) ' Measure each time as this is a surrogate indicator for analog errors - when it has noise in the data
  Battery(BatteryVoltage) ' Measure using the CR300 battery voltage hardware
  If ReadStatusSensors Then
    ReadGPSNow = True
    Call WritePort(Vx2, True) ' Start with 3.3V for humidity. Must be 3V3 or the output will be above 2.5V for SE channel.  Have tested 5V sensor to read correctly at 3V3
    VoltSe(HumidityVoltage, 1, mV2500, HUMIDITY_PORT, True, 50000,FILTER_FREQUENCY, 1.0, 0)
    InternalHumidity = (((HumidityVoltage/3300)-0.1515)/0.0052)/(1.0546-0.00216*InternalTemperature)
    If InternalHumidity > 100 Then InternalHumidity = 100
    If InternalHumidity > 80 Then Message = "Change desiccant ASAP, condensation likely.  Ref: Ai1 manual section 22.":  Call AddTime: Errors = Message
    ExciteV(Vx2,5000,0) ' Barometer uses 5V excitation
    For i = 1 To PRESSURE_READINGS
      VoltSe(PressureArray(i), 1, mv2500, PRESSURE_PORT, True, 2000, 50, 0.001, 0) ' Measure the voltage of the barometric pressure sensor.  Sensor uses 5V excitation.  0.001 convert to volts
    Next i
    SortSpa(PressureArray(), PRESSURE_READINGS, PressureArray())
    Pressure_Voltage = PressureArray(Ceiling(PRESSURE_READINGS/2))
    If PressureFirstReading Then ' First time through the program fill the array with the initial value
      For i = 1 To PRESSURE_TIME_AVERAGING
        PressureTimeArray(i) = Pressure_Voltage
      Next i
      PressureFirstReading = False ' Only do this first time through
    Else
      For i = 1 To PRESSURE_TIME_AVERAGING - 1
        PressureTimeArray(i) = PressureTimeArray(i + 1)
      Next i
      PressureTimeArray(PRESSURE_TIME_AVERAGING) = Pressure_Voltage
    EndIf
    SortSpa(PressureTimeArraySorted(), PRESSURE_TIME_AVERAGING, PressureTimeArray())
    Pressure_Voltage = PressureTimeArraySorted(Ceiling(PRESSURE_TIME_AVERAGING/2))
    Pressure_hPa = (0.725*Pressure_Voltage-0.2625)*1000
    Pressure_mH2O = (Pressure_hPa - 1013.25) * hPa_TO_m ' Offset relative to standard atmospheric pressure
    Call WritePort(Vx2, True)
    ExciteV(Vx2, 5000, 0) ' Step up to 5V for other internal sensors
    VoltSe(Current_mV, 1, mv2500, CURRENT_PORT, True, 0, FILTER_FREQUENCY, 1, 0) ' Read the raw mV output. Settling time is from humidity sensor
    Current_mA = (Current_mV - CURRENT_ZERO_mV) * 5 ' Normal output is 400mA/1000mV, or 2.5mV/mA, but with 2:1 voltage divider it is 5mV/mA
    ReadStatusSensors = False
  EndIf

  Call ReadGPS

  If BatteryVoltage < LOW_BATTERY_SHUTDOWN_V Then
    If ReadNow Then ' If brownout when reading, display the error so it isn't lost
      If(Left(Errors,17) <> Left("Low Battery Warning",17)) Then Call ErrorLog("Low Battery Warning, Brownout during measurement. " + BatteryVoltage + "V.  Note only" )
    Else  ' if not during a measurement then turn off the modem as well
      CommsPowerOnStatus = false
      IPNetPower(5, 0, 0)
      If(Left(Errors,17) <> Left("Low Battery Shutdown",17)) Then Call ErrorLog("Low Battery Shutdown, Modem off. " + BatteryVoltage + "V.  Ref: Ai1_manual section 9.2" ) ' Only store is this is a new message
    EndIf
  Else
    If (BatteryVoltage < LOW_BATTERY_SAVER_V) AND ((Hour < 6) OR (Hour > 18)) Then
      If(Left(Errors,17) <> Left("Low Battery Saver",17)) Then Call ErrorLog("Low Battery Saver, Communications turned off overnight. " + BatteryVoltage + "V.  Ref: Ai1_manual section 9.2") ' Only store if this is a new message
      CommsPowerOnStatus = false
      IPNetPower(5, 0, 0)
    Else
      If CommsPowerOnStatus = false Then
        If ProgramCounter > LastProgramCounter + 10 Then ' Only cycle power if not recently done
          Call ErrorLog("Battery power restored, resuming normal operation.  Ref: Ai1_manual section 9.2")
          CommsPowerOnStatus = true
          IPNetPower(5, 1, 0) ' Modem on
        EndIf
      EndIf
    EndIf
  EndIf
  CallTable Ai1
  ProgramCounter += 1 ' Increment the program counter
  ProcessingTime = Status.ProcessTime ' checking that the program executes cleanly.  Should be last instruction
EndSub

Const HISTORY_RECORDS As Long = 3
Public ErrorHistory(HISTORY_RECORDS) As String * 96 ' Retain recent messages
Sub ErrorLog(ErrorMessage As String * 96)
  Errors = ErrorMessage + ". " + Public.Timestamp(2,1)
  For i = 1 To (HISTORY_RECORDS - 1)
    ErrorHistory(i) = ErrorHistory(i+1)
  Next i
  ErrorHistory(HISTORY_RECORDS) = Errors
  LastProgramCounter = ProgramCounter ' Program cycle when error occurred
EndSub

BeginProg
  Call Initialization

  Scan (SCAN_INTERVAL_S, Sec, 0, 0)
    Call SensorMeasurements
  NextScan

  SlowSequence
    Scan (SCAN_INTERVAL_S, Sec, 0, 0)
      Call SystemCheck
    NextScan
  EndSequence

  SlowSequence
    Scan (60, Sec, 0, 0)
      Call Hydrosphere
    NextScan
  EndSequence
EndProg
