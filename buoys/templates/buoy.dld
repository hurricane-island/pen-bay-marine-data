StationName = $STATION_NAME ' No quotes!
Const HYDROSPHERE_ID = "$CLIENT_ID" ' Hydrosphere site.
Const PAKBUS_ADDRESS As Long = $PAKBUS_ADDRESS ' network address
Const TCP_CLIENT As String = "(drema.konectgds.com,9200)" ' Pakbus Router
Public AccessPointName As String = "so01.VZWSTATIC" ' Cell APN
Const OBSERVED_PROPERTIES = 14
Const HYDROSPHERE_HOST As String = "stormcentral.waterlog.com"
Const HYDROSPHERE_PORT As Long = 32212
Const HYDROSPHERE_MAX_RETRIES As Long = 5 ' Hydrosphere connection attempts
Const QUEUE_SIZE As Long = 96 ' 96 is required for 15min data, for 12 hours - if daily updates are used
Const HYDROSPHERE_TIMEOUT As Long = 500 ' x 0.01s
Const SDI12 As Long = 1
Const RS232 As Long = 2
Const ANALOG As Long = 3
Const RS485 As Long = 4
Const ABSOLUTE As Long = 1
Public Errors As String * 128 = ""
Public Message As String * 256 = ""
' Dim PortsON As Long = 0
Const SCAN_INTERVAL_S As Long = 5 ' Program scan Interval.
Const MEASUREMENT_INTERVAL_S As Long = 600 ' Sensor measurement interval
Const SLOW_MEASUREMENT_INTERVAL_S As Long = 300 ' interval for less critical measurements, such as GPS
Const LOW_BATTERY_SAVER_V = 12.83
Const LOW_BATTERY_SHUTDOWN_V = 12.75' V  ' Battery protection thresholds.
Const CELL_WINDOW_START As Long = 1440
Const CELL_WINDOW_DURATION As Long = 10
Const CELL_WINDOW_FREQUENCY As Long = 1440  ' Modem is always on when CELL_WINDOW_START = 1440
Const CURRENT_ZERO_mV As Long = 1250 ' mV.To recalibrate: Remove fuse and power Ai1 from charging input, measure Current_mV

Const SENSOR_QTY As Long = 1  ' Number of sensors fitted to this station, repeat the measurements on sequential ports or address
Const TABLE_WQ As Long = 200000
Const SONDE_USED As Boolean = TRUE
Const SONDE_USES_RS485 As Boolean = True
Const SONDEVALUES_TBL_SIZE As Long = 5000
Const PRESSURE_TYPE As Long = ABSOLUTE
Const PRESSURE_FSR_PSI As Float = 43.5
Const TRANSFER As Float = 0.1 ' Pressure sensor configuration
Const PRESSURE_PORT As Long = 3
Const PRESSURE_INTERFACE As Long = ANALOG
' Const SENSOR_POWER_PORT As Long = SW12V
Const GPS_PORT As Long = ComC2_Rx
Const YSIPPORT As Long = ComRS232
Dim Ai1WipesSonde As Boolean = True
' PreserveOneVariable(Ai1WipesSonde)
Dim ObservedProperty(OBSERVED_PROPERTIES) As Long ' points to the address of each variable to send
Public ExternalTemp As Float ' First reading from the sonde, use this instead of External_Temp

' Caution editing above here'
Include "CPU:YSIP_CONST_Enc.CR300"
Include "CPU:YSIP_CORE_Enc.CR300"
' OK to edit below here'

Dim Ai1OSVersion As Float = 0.75
Dim DataloggerOSVersion As Float ' Used for holding CR300 OS version
Const FILTER_FREQUENCY As Long = 4000 ' Set to 50 or 60 for situations with AC noise, otherwise 4000Hz provides quickest processing
Const TIMER_STOP As Long = 1
Const TIMER_RESET_AND_START As Long = 2
Const TIMER_READ As Long = 4
Const ALLOW_SLEEP As Long = 1
Const GPS_TIMER As Long = 11
Const CR = CHR(13)
Const hPa_TO_m As Float = 0.0101972
Const CURRENT_PORT As Long = 5
Const HUMIDITY_PORT As Long = 6
Const READ_ATTEMPTS_LIMIT As Long = 4
Public ReadAttempts As Long ' Times sensor read was attempted
Dim ProgramCounter As Long: Units ProgramCounter = Cycles ' Program cycles since power up
Dim LastProgramCounter As Long: Units LastProgramCounter = Cycles ' Error tracking
Public BatteryVoltage As Float: Units BatteryVoltage = Volts
Dim Vx1Voltage As Long
Dim Vx2Voltage As Long ' Keep track of the excitation port voltage so that it can safely be turned off after status readings 
Const PRESSURE_PARAMETERS As Long = 3
Public Pressure(PRESSURE_PARAMETERS) As Float
Alias Pressure(1) = Pressure_Voltage: Units Pressure_Voltage = Volts
Alias Pressure(2) = Pressure_hPa: Units Pressure_hPa = hPa
Alias Pressure(3) = Pressure_mH2O: Units Pressure_mH2O = mH2O
Const PRESSURE_READINGS As Long = 7 ' Number of measurements to take from averaging this single reading
Const PRESSURE_TIME_AVERAGING As Long = 5 ' Time averaging of pressure readings
Dim PressureArray(PRESSURE_READINGS) As Float ' Array to hold readings from which the median value is used
Dim PressureTimeArray(PRESSURE_TIME_AVERAGING) As Float ' Array to hold the time series of median filtered readings
Dim PressureTimeArraySorted(PRESSURE_TIME_AVERAGING) ' To hold the sorted values for median selection
Dim PressureFirstReading As Boolean = True ' First time through, copy the initial value to all elements in array
Public Current_mA As Long: Units Current_mA = mA ' Use long so that only whole numbers are returned
Dim Current_mV As Float: Units Current_mV = mV
Public InternalTemperature As Float: Units InternalTemperature = °C
Public InternalHumidity As Long: Units InternalHumidity = % ' Report only whole numbers
Public HumidityVoltage As Float: Units HumidityVoltage = mV
Public ProcessingTime: Units ProcessingTime = µS
Dim rTime(9)
Alias rTime(1) = Year
Alias rTime(2) = Month
Alias rTime(3) = DayOfMonth
Alias rTime(4) = Hour
Alias rTime(5) = Minute
Alias rTime(6) = Second
Alias rTime(7) = uSecond
Dim i As Long ' For internal counters only
Dim AddressToRead As Long ' Used by several subroutines, for holding a memory address for a pointer

Sub AddTime ' Adds time onto end of message, formatted to H:MM:SS
  Message += Hour + ":"
  If Minute < 10 Then Message += "0" 
  Message += Minute + ":"
  If Second < 10 Then Message += "0"
  Message += Second
EndSub

Sub AddDate
  Message += ", " + DayOfMonth + "/" + Month + "/" + Year + "."
EndSub 

Dim CommsPowerOnStatus As Boolean = True
Dim CellBillingDay = 1 ' Day of Month

Public ReadNow As Boolean = False
Public ReadStatusSensors As Boolean = False

Public Measurements________ As Boolean = False
Dim SensorPowerStatus: Units SensorPowerStatus = Returns True If Sensor Is ON
Public GPSPowerStatus As Boolean: Units GPSPowerStatus = Returns True If GPS Is ON
Const GPS_BAUD As Long = 9600
Const GPS_BUFFER As Long = 512 ' The uBlox GPS output

Public SondeReadFailed As Boolean = False
Alias SondeValuesSorted(45) = Sonde_Future1
Alias SondeValuesSorted(46) = Sonde_Future2
Alias SondeValuesSorted(47) = Sonde_Future3
Alias SondeValuesSorted(48) = Sonde_Future4
Alias SondeValuesSorted(49) = Sonde_Future5
Alias SondeValuesSorted(50) = Sonde_Future6
Alias SondeValuesSorted(51) = Sonde_Future7
Alias SondeValuesSorted(52) = Sonde_Future8
Alias SondeValuesSorted(53) = Sonde_Future9
Alias SondeValuesSorted(54) = Sonde_Future10
Alias SondeValuesSorted(55) = Sonde_Future11
Alias SondeValuesSorted(56) = Sonde_Future12
Alias SondeValuesSorted(57) = Sonde_Future13
Alias SondeValuesSorted(58) = Sonde_Future14
Alias SondeValuesSorted(59) = Sonde_Future15
Alias SondeValuesSorted(60) = Sonde_Future16


Public Queue(QUEUE_SIZE) As String *(22+OBSERVED_PROPERTIES*10)
Public Labels As String *(OBSERVED_PROPERTIES*26)
Dim NextRecord As Long = 1
Dim Name(OBSERVED_PROPERTIES) As String * 26 ' up to 24 characters

Sub Hydrosphere
  Dim Socket As Long
  Dim Output As Long
  Dim Attempts As Long = 0

  If NextRecord > 1 Then
    Do While NextRecord > 1 AND Attempts < HYDROSPHERE_MAX_RETRIES
      Attempts += 1
      Socket = TCPOpen(HYDROSPHERE_HOST, HYDROSPHERE_PORT, 1000, HYDROSPHERE_TIMEOUT)
      If Socket <> 0 Then
        SerialFlush(Socket)
        SerialOut(Socket, "SL(" + HYDROSPHERE_ID + ")" + CR, "OK", 1, HYDROSPHERE_TIMEOUT)
        SerialOut(Socket, Labels, "OK", 1, HYDROSPHERE_TIMEOUT)
        Output = SerialOut(Socket, Queue(1), "OK", 1, HYDROSPHERE_TIMEOUT)
        SerialOut(Socket, "DIS" + CR, "OK", 1, HYDROSPHERE_TIMEOUT)
        TCPClose(Socket)
      Else
        Message = "No connection"
        Output = 0 ' Make sure that the last OK is not still in the status
      EndIf
      If Output = 2 Then ' If "OK" was sent
        If NextRecord > 2 Then ' If we have at least 2 values, shift left.
          For i = 1 To (NextRecord - 2)
            Queue(i) = Queue(i+1)
          Next i
        EndIf
        NextRecord -= 1
        Queue(NextRecord) = "" ' Clear buffer
        Message = "Report " + NextRecord + " sent"
      ElseIf Attempts = HYDROSPHERE_MAX_RETRIES Then 
        Message = "Tx failed after " + Attempts + " attempts"
      Else
        Message = "No OK (" + Output + "). Retrying..."
      EndIf
    Loop
  Else
    Message = "No data to send"
  EndIf

  RealTime(rTime) ' Update timestamp
  Message += ". "
  Call AddTime
  Message += "."
EndSub


Const GPS_PARAMETERS As Long = 9 ' 1=Time(UTC),2=Date,3=Lat(ddmm),4=Lat(.mmmmmm),5=Long(ddmm),6=Long(.mmmmmm),7=Alt,8=Fix,9=#Sat
Dim GPSReadings(GPS_PARAMETERS) As Float
Public GPSString As String * GPS_BUFFER: Units GPSString = NMEA 0183 Processed String
Const GPS_HEADER As String = "$GPGGA" ' This is the header of the GPS string
Dim CommaCount As Long ' Use to make sure I have enough data
Dim GPSReadingsString(GPS_PARAMETERS) As String * 16
Dim RawGPSString As String * GPS_BUFFER
Dim GPSStart As Long: Units GPSStart = Start character For NMEA Message
Dim GPSEnd As Long: Units GPSEnd = End character For NMEA Message
Dim GPSLength As Long: Units GPSLength = characters in NMEA Message
Dim Comma1 As Long
Dim Comma2 As Long
Dim InternalCounter As Long
Alias GPSReadings(1) = GPS_UTCtime: Units GPS_UTCtime = HHMMSS
Alias GPSReadings(2) = GPS_Latitude_dddmm: Units GPS_Latitude_dddmm = dddmm.mmmm
Alias GPSReadings(3) = GPS_LatitudeHemisphere: Units GPS_LatitudeHemisphere = 1=N, -1=S
Alias GPSReadings(4) = GPS_Longitude_dddmm: Units GPS_Longitude_dddmm = dddmm.mmmm
Alias GPSReadings(5) = GPS_LongitudeHemisphere: Units GPS_LongitudeHemisphere = 1=E, -1=W
Alias GPSReadings(6) = GPS_QualityIndicator: Units GPS_QualityIndicator = 0=NoFix,1=GPS,2=DIFFERENTIAL
Alias GPSReadings(7) = GPS_Satellites: Units GPS_Satellites = count
Alias GPSReadings(8) = GPS_HDOP: Units GPS_HDOP = error estimate
Alias GPSReadings(9) = GPS_Height: Units GPS_Height = meters
Public Latitude As Float: Units Latitude = Decimal Degrees (N=+,S=-)  ' Latitude recombined into a single value.  These are what are stored in the data tables
Public Longitude As Float: Units Longitude = Decimal Degrees (E=+,W=-)
Public UTCTime As Long: Units UTCTime = HHMMSS
Dim UTCDate As Long: Units UTCDate = YYMMDD
Dim GPSFix As Long: Units GPSFix = 0=No FIX, 1=FIX, 2=DIFFERENTIAL FIX
Public GPSSatellitesInView As Long: Units GPSSatellitesInView = GPS Satellites visible
PreserveOneVariable(Latitude)
PreserveOneVariable(Longitude) ' Save these values so a power cycle does not reset them and cause the icon to jump around
Public GPSSatellitesRequired As Long = 4
PreserveOneVariable(GPSSatellitesRequired) ' Specifies the required satellites for an accurate GPS fix.  Up to 7 or 8 is possible
Const GPS_MAX_ON_TIME As Long = 180 ' turns off this many seconds

Sub GPSOff
  ExciteV(Vx2, 0, 0) ' Turn off the power to the GPS and other internal status sensors
  Message = "GPS reading complete, turning off internal sensor power"
  Timer(GPS_TIMER, Sec, TIMER_STOP)
  GPSPowerStatus = False
EndSub

DataTable(Ai1, True, 3000) ' Records status information for remote diagnostics
  DataInterval(0, SLOW_MEASUREMENT_INTERVAL_S, Sec, 0)
  Sample(1, BatteryVoltage, FP2)
  Sample(1, InternalTemperature, FP2)
  Sample(1, InternalHumidity, FP2)
  Average(1, Current_mA, FP2, False): FieldNames("CurrentAverage:mA"): Units CurrentAverage = mA (-=Charge, +=Discharge)
  Maximum(1, Current_mA,FP2, False, False): FieldNames("CurrentMaximum:mA"): Units CurrentMaximum = mA (-=Charge, +=Discharge)
  Sample(1, ProcessingTime, UINT2)
  Sample(1, Status.SerialNumber, UINT2)
  Sample(1, DataloggerOSVersion, FP2)
  Sample(1, Ai1OSVersion, FP2)
  Sample(1, Status.ProgSignature, UINT2): FieldNames("ProgramSignature:0-65535)"): Units ProgramSignature = (0-65535)
  Sample(1, ProgramCounter, Long)
  Sample(1, Status.StartUpCode, FP2): FieldNames("StartUpCode:0=Ok,-1=Power Loss,-2=Watchdog"): Units StartUpCode = (0=Ok, -1=Power, -2=Watchdog)
  Sample(1, Status.WatchdogErrors, FP2): FieldNames("WatchdogErrors:Watchdog Errors Since Compile"): Units WatchdogErrors = Errors Since Compile
  Sample(1, Status.SkippedScan, FP2): FieldNames("SkippedScans:Scans Skipped"): Units SkippedScans = Scans Skipped
  Sample(1, Status.MemoryFree, UINT2): FieldNames("MemoryFree:Bytes"): Units MemoryFree = Bytes
  Sample(1, Status.CellUsageToday, FP2): FieldNames("CellUsageToday:kB"): Units CellUsageToday = kB
  Sample(1, Status.CellUsageMonth, Long): FieldNames("CellUsageThisMonth:kB"): Units CellUsageThisMonth = kB 
  Sample(1, Status.CellRSSI, FP2): FieldNames("CellRSSI:dBm"): Units CellRSSI = dBm
  Sample(1, Status.CellNetBand, FP2): FieldNames("CellNetBand:band")
  Sample(1, Latitude, IEEE4)
  Sample(1, Longitude, IEEE4)
  Sample(1, GPSSatellitesInView, FP2)
  Sample(1, Pressure_mH2O, FP2)
  Maximum(1, ReadAttempts, UINT2, False, False)
EndTable


Sub Initialization
  AddressToRead = 0 ' Stops a warning if not used
  Call GPSOff ' turn the GPS off to put the power output port and regulator in a known state
  SerialOpen(GPS_PORT, GPS_BAUD, 0, 0, GPS_BUFFER, ALLOW_SLEEP)
  Message = "Initializing... "
  RealTime(rTime)
  Call ErrorLog("Program restart") ' Record the program restart in the error log
  Delay(0, 500, mSec) ' Have a short delay incase multiple messages are generated

  Measurements________ = false
  i = 0  ' Just to stop a compile warning that it is unused
  SetSetting("PakBusTCPClients", TCP_CLIENT)
  SetSetting("PakBusAddress", PAKBUS_ADDRESS)
  Battery(BatteryVoltage) ' Get a battery voltage reading so that on first execution it will have a reading
  SetSetting("CellEnabled", True) ' Make sure that the modem is turned on
  SetSetting("CellAPN", AccessPointName) ' Configure the APN.  It is possible to set this through the constant table
  SetSetting("CellPwrStartTime", CELL_WINDOW_START) ' When to power up the modem
  SetSetting("CellPwrDuration", CELL_WINDOW_DURATION) ' How long is each window
  SetSetting("CellPwrRepeat", CELL_WINDOW_FREQUENCY) ' When does the window repeat, i.e. hourly
  SetSetting("CellBillingDay", CellBillingDay) ' When to roll over the monthly usage
  SetSetting("CellKeepAlive", "www.google.com") ' verify network connectivity.  If this fails, the datalogger will re-establish
  SetSetting("CellKeepAliveTime", 30) ' How often to ping test the link
  CommsPowerOnStatus = true
  IPNetPower(5, 1, 0) ' Make sure modem is turned on
  WriteIO(&B01000000, &B01000000)
  ExciteV(Vx1, 5000, 0)
  Message = "Powering sonde (25s remaining)"
  Delay(0, 25, Sec)
  YSIPInit()
  findSonde(3)
  Message = "Sonde initialized. "
  ExciteV(Vx1, 0, 0) ' Turn off RS485 adapter.
  WriteIO(&B01000000, 0)
  If Status.LithiumBattery < 3.0 Then ' Check diagnostics are record to ErrorLog if a problem
    Call ErrorLog("Low (or no) Lithium Battery = " + Status.LithiumBattery)
    Delay(0, 500, mSec) ' Log with delay in case multiple messages are generated
  EndIf
  If Status.WatchdogErrors > 0 Then
    Call ErrorLog("Watchdog errors = " + Status.WatchdogErrors)
    Delay(0, 500, mSec) ' Log with delay in case multiple messages are generated
  EndIf
  ' Check that all the measurement parameters are correct and evenly divisible (or measurements wont be taken correctly)
  If MEASUREMENT_INTERVAL_S MOD SCAN_INTERVAL_S > 0 Then Call ErrorLog("MEASUREMENT_INTERVAL_S (" + MEASUREMENT_INTERVAL_S + " sec) needs to be a multiple of SCAN_INTERVAL_S (" + SCAN_INTERVAL_S + " sec)")
  If SLOW_MEASUREMENT_INTERVAL_S MOD SCAN_INTERVAL_S > 0 Then Call ErrorLog("SLOW_MEASUREMENT_INTERVAL_S (" + SLOW_MEASUREMENT_INTERVAL_S + " sec) needs to be a multiple of SCAN_INTERVAL_S (" + SCAN_INTERVAL_S + " sec)")
  DataloggerOSVersion = Right(Status.OSVersion, 5) ' Get the OS version and convert to a string, only needed at startup.  5 characters works for OS > 10.01
  Message += "System initialization complete."
  Call AddDate
EndSub


Sub SensorMeasurements
  Public Serialized As String *(22+OBSERVED_PROPERTIES*10) ' The string repr of one full record
  Dim Values(OBSERVED_PROPERTIES) As Float ' values to send
  Dim WQTemporaryRS485(YSISWATH) As Float ' hold returned values prior to confirming as valid
  If TimeIntoInterval(0, MEASUREMENT_INTERVAL_S, Sec) Then 
    ReadNow = True
  EndIf
  If (ReadNow) Then
    Message = "Powering RS485 adapter for communications"
    WriteIO(&B01000000, &B01000000)
    ExciteV(Vx1, 5000, 0) ' Turn on the RS485 adapter
    Delay(0, 200, mSec) ' Short delay to allow sonde to wake up
    WQTemporaryRS485() = SondeValuesSorted() ' Save previous values
    If NOT sondefound Then findSonde(3) ' If the sonde hasn't been found, then attempt to find first
    If Ai1WipesSonde Then ' When using Sample&Hold in the sonde, the sonde controls the wiping frequency, no need to duplicate here
      Message = "Allowing time for sonde wiper."
      startWipe() ' full wipe is 2 in each direction, takes approximately 22-25s
      getWipeStatus()
      For i = 40 To 1 Step -1
        Delay(0, 1, Sec)
        Message = "Allowing time for sonde wiper (" + i + "s remaining)"
      Next i
    EndIf
    Message = "Reading sonde and updating available parameters. "
    sondeCheck()
    getSondeParams() ' Handle any sonde changes and update parameters
    ReadAttempts = 0
    Do
      ReadAttempts += 1
      Message = "Reading sonde values, attempt " + ReadAttempts
      Sonde_External_Voltage = NaN
      External_Temp = NaN
      Depth = NaN ' Prepare parameters to check with NaN so that a successful read is identified
      getSondeValues() ' Populate available parameters
      sortYSIPData()
      ExternalTemp = External_Temp ' Map the temperature reading so that Hydrosphere and Satellite naming will work
      SondeReadFailed = False
      If (Sonde_External_Voltage = NaN) AND (WiperPosition = NAN) Then SondeReadFailed = True ' NAN's occur if there is no communications to sonde
      If (Sonde_External_Voltage = 0) AND (WiperPosition = 0) Then SondeReadFailed = True ' 0's can occur if the sonde has failed to measure sensors yet, but ready to talk
    Loop While (SondeReadFailed AND (ReadAttempts <= READ_ATTEMPTS_LIMIT)) ' Repeat if the read failed (any non-NaN value will mark success)
    If SondeReadFailed Then ' Restore the previous values
      SondeValuesSorted() = WQTemporaryRS485()
      Message = "No valid Data ("
      If Sonde_External_Voltage = NaN Then 
        Message += "NAN returned"
      ElseIf Sonde_External_Voltage = 0 Then Message += "Zero's returned"
        Message += "Unspecified response"
      EndIf
      Message += "), restoring previous values. "
      Call AddTime
      Call AddDate
      Errors = Message ' Message only, not logged
    Else
      Message = "Sonde read completed"
      getSondeSN()
      CallTable SondeValues ' Only store if successful
    EndIf
    CallTable YSISondeMeta
    Message += ".  Shutting down RS485 adapter"
    ExciteV(Vx1, 0, 0) ' sonde in low power state
    WriteIO(&B01000000, 0)
    ReadNow = False
  EndIf

  ObservedProperty(1) = @ExternalTemp
  ObservedProperty(2) = @SpConductivity_us
  ObservedProperty(3) = @Pressure_abs
  ObservedProperty(4) = @Chlorophyll_ugL
  ObservedProperty(5) = @Chlorophyll_RFU
  ObservedProperty(6) = @BGA_PE_ugL
  ObservedProperty(7) = @BGA_PE_RFU
  ObservedProperty(8) = @BatteryVoltage
  ObservedProperty(9) = @InternalHumidity
  ObservedProperty(10) = @Salinity
  ObservedProperty(11) = @ODO
  ObservedProperty(12) = @ODO_Sat
  ObservedProperty(13) = @Latitude
  ObservedProperty(14) = @Longitude

  For i = 1 To OBSERVED_PROPERTIES
    Name(i) = !(ObservedProperty(i)) ' name of memory location is the canonical vendor name
    AddressToRead = (ObservedProperty(i)) ' Cannot read the value directly
    Values(i) = !AddressToRead
  Next i
  RealTime(rTime)
  Serialized = "D=" + FormatFloat(Month,"%02.0f") + "/" + FormatFloat(DayOfMonth,"%02.0f") + "/" + FormatFloat((Year MOD 100),"%02.0f") + "," + FormatFloat(Hour,"%02.0f") + ":" + FormatFloat(Minute,"%02.0f") + ":" + FormatFloat(Second,"%02.0f") + ","
  Labels = "SN="
  For i = 1 To OBSERVED_PROPERTIES
    Labels += Name(i)
    Serialized += Values(i)
    If i < OBSERVED_PROPERTIES Then 
      Serialized += ","
      Labels += ","
    EndIf
  Next i
  If NextRecord <= QUEUE_SIZE Then
    Queue(NextRecord) = Serialized + CR
    NextRecord += 1
  EndIf
EndSub


Sub SystemCheck
  If TimeIntoInterval(0, SLOW_MEASUREMENT_INTERVAL_S, sec) Then
    ReadStatusSensors = True
  EndIf
  PanelTemp(InternalTemperature, FILTER_FREQUENCY)
  Battery(BatteryVoltage)
  If ReadStatusSensors Then
    ExciteV(Vx2, 3300, 0) ' Must be 3V3 or the output will be above 2.5V for SE channel.
    VoltSe(HumidityVoltage, 1, mV2500, HUMIDITY_PORT, True, 50000, FILTER_FREQUENCY, 1.0, 0)
    InternalHumidity = (((HumidityVoltage/3300)-0.1515)/0.0052)/(1.0546-0.00216*InternalTemperature)
    If InternalHumidity > 100 Then InternalHumidity = 100
    If InternalHumidity > 80 Then Message = "Change desiccant ASAP, condensation likely.  Ref: Ai1 manual section 22.":  Call AddTime: Errors = Message
    ExciteV(Vx2, 5000, 0) ' Barometer uses 5V excitation
    For i = 1 To PRESSURE_READINGS
      VoltSe(PressureArray(i), 1, mv2500, PRESSURE_PORT, True, 2000, 50, 0.001, 0) ' Measure the voltage of the barometric pressure sensor.  Sensor uses 5V excitation.  0.001 convert to volts
    Next i
    SortSpa(PressureArray(), PRESSURE_READINGS, PressureArray())
    Pressure_Voltage = PressureArray(Ceiling(PRESSURE_READINGS/2))
    If PressureFirstReading Then ' First time through the program fill the array with the initial value
      For i = 1 To PRESSURE_TIME_AVERAGING
        PressureTimeArray(i) = Pressure_Voltage
      Next i
      PressureFirstReading = False ' Only do this first time through
    Else
      For i = 1 To PRESSURE_TIME_AVERAGING - 1
        PressureTimeArray(i) = PressureTimeArray(i + 1)
      Next i
      PressureTimeArray(PRESSURE_TIME_AVERAGING) = Pressure_Voltage
    EndIf
    SortSpa(PressureTimeArraySorted(), PRESSURE_TIME_AVERAGING, PressureTimeArray())
    Pressure_Voltage = PressureTimeArraySorted(Ceiling(PRESSURE_TIME_AVERAGING/2))
    Pressure_hPa = (0.725*Pressure_Voltage-0.2625)*1000
    Pressure_mH2O = (Pressure_hPa - 1013.25) * hPa_TO_m ' Offset relative to standard atmospheric pressure
    ExciteV(Vx2, 3300, 0)
    ExciteV(Vx2, 5000, 0) ' Step up to 5V for other internal sensors
    VoltSe(Current_mV, 1, mv2500, CURRENT_PORT, True, 0, FILTER_FREQUENCY, 1, 0) ' Read the raw mV output. Settling time is from humidity sensor
    Current_mA = (Current_mV - CURRENT_ZERO_mV) * 5 ' Normal output is 400mA/1000mV, or 2.5mV/mA, but with 2:1 voltage divider it is 5mV/mA
    ReadStatusSensors = False

    If NOT(GPSPowerStatus) Then
      Message = "Powering GPS for location tracking. "
      ExciteV(Vx2, 3300, 0)
      ExciteV(Vx2, 5000, 0) ' Then set it to 5V which is higher than the 3.3V default
      GPSPowerStatus = True
      Timer(GPS_TIMER, Sec, TIMER_RESET_AND_START) ' Start timer
    EndIf
    If (Timer(GPS_TIMER, Sec, TIMER_READ) > GPS_MAX_ON_TIME) Then
      Call GPSOff
      Message = "GPS timer shutdown"
    EndIf
    SerialIn(RawGPSString, GPS_PORT, 50, 0, GPS_BUFFER) ' Read in the serial data
    SerialFlush(GPS_PORT) ' Clear out any data so a fresh reading is taken next cycle
    GPSStart = InStr(1, RawGPSString, GPS_HEADER, 2) ' position of $GPGGA (start)
    GPSEnd = InStr(GPSStart+1, RawGPSString, "M", 2) ' position of the terminator
    If (GPSStart>0) AND (GPSEnd>0) Then
      GPSString = Mid(RawGPSString,GPSStart,GPSEnd-GPSStart)  ' Get the part between the start and the end
      GPSLength = Len(GPSString)
      Comma2 = 1
      CommaCount = 0 ' Now parse the information and convert to double precision data, starting at the start of the string
      For InternalCounter = 1 To GPS_PARAMETERS
        Comma1 = InStr(Comma2, GPSString, ",", 2)
        Comma2 = InStr(Comma1+1, GPSString, ",", 2) ' Start searching at the position of the last comma
        If Comma2 > 0 Then
          GPSReadingsString(InternalCounter) = Mid(GPSString,Comma1+1,Comma2-Comma1-1) ' If it isn't above zero, the string was truncated for some reason
          CommaCount+=1
        EndIf
      Next InternalCounter
      For InternalCounter = 1 To GPS_PARAMETERS
        GPSReadings(InternalCounter) = GPSReadingsString(InternalCounter) ' Convert from string to double
      Next InternalCounter
      If CommaCount >= 9 AND (GPSReadings(7) >= GPSSatellitesRequired) Then ' We have enough satellites so save the information
        Latitude = Floor(GPS_Latitude_dddmm / 100.0) + (GPS_Latitude_dddmm MOD 100)/60
        Longitude = Floor(GPS_Longitude_dddmm / 100.0) + (GPS_Longitude_dddmm MOD 100)/60
        If GPSReadingsString(3) = "S" Then ' Add the sign to the latitude / longitude
          GPSReadings(3) = -1
          GPS_Latitude_dddmm = -GPS_Latitude_dddmm
          Latitude = -Latitude
        Else
          GPSReadings(3) = 1
        EndIf
        If GPSReadingsString(5) = "W" Then
          GPSReadings(5) = -1
          GPS_Longitude_dddmm = -GPS_Longitude_dddmm
          Longitude = -Longitude
        Else
          GPSReadings(5) = 1
        EndIf
        GPSFix = GPS_QualityIndicator
        UTCTime = GPS_UTCtime
        UTCDate = 0
        GPSSatellitesInView = GPS_Satellites ' UTCDate isn't part of serial message
        Message = "GPS location complete, using " + GPSReadings(7) + " satellites."
        Call GPSOff
      EndIf
    EndIf
  EndIf

  If BatteryVoltage < LOW_BATTERY_SHUTDOWN_V Then
    If ReadNow Then ' If brownout when reading, display the error so it isn't lost
      If(Left(Errors,17) <> Left("Low Battery Warning",17)) Then Call ErrorLog("Low Battery Warning, Brownout during measurement. " + BatteryVoltage + "V.  Note only" )
    Else  ' if not during a measurement then turn off the modem as well
      CommsPowerOnStatus = false
      IPNetPower(5, 0, 0)
      If(Left(Errors,17) <> Left("Low Battery Shutdown",17)) Then Call ErrorLog("Low Battery Shutdown, Modem off. " + BatteryVoltage + "V.  Ref: Ai1_manual section 9.2" ) ' Only store is this is a new message
    EndIf
  Else
    If (BatteryVoltage < LOW_BATTERY_SAVER_V) AND ((Hour < 6) OR (Hour > 18)) Then
      If(Left(Errors,17) <> Left("Low Battery Saver",17)) Then Call ErrorLog("Low Battery Saver, Communications turned off overnight. " + BatteryVoltage + "V.  Ref: Ai1_manual section 9.2") ' Only store if this is a new message
      CommsPowerOnStatus = false
      IPNetPower(5, 0, 0)
    Else
      If CommsPowerOnStatus = false Then
        If ProgramCounter > LastProgramCounter + 10 Then ' Only cycle power if not recently done
          Call ErrorLog("Battery power restored, resuming normal operation.  Ref: Ai1_manual section 9.2")
          CommsPowerOnStatus = true
          IPNetPower(5, 1, 0) ' Modem on
        EndIf
      EndIf
    EndIf
  EndIf
  CallTable Ai1
  ProgramCounter += 1 ' Increment the program counter
  ProcessingTime = Status.ProcessTime ' checking that the program executes cleanly.  Should be last instruction
EndSub

Const HISTORY_RECORDS As Long = 3
Public ErrorHistory(HISTORY_RECORDS) As String * 96 ' Retain recent messages
Sub ErrorLog(ErrorMessage As String * 96)
  Errors = ErrorMessage + ". " + Public.Timestamp(2,1)
  For i = 1 To (HISTORY_RECORDS - 1)
    ErrorHistory(i) = ErrorHistory(i+1)
  Next i
  ErrorHistory(HISTORY_RECORDS) = Errors
  LastProgramCounter = ProgramCounter ' Program cycle when error occurred
EndSub

BeginProg
  Call Initialization

  Scan (SCAN_INTERVAL_S, Sec, 0, 0)
    Call SensorMeasurements
  NextScan

  SlowSequence
    Scan (SCAN_INTERVAL_S, Sec, 0, 0)
      Call SystemCheck
    NextScan
  EndSequence

  SlowSequence
    Scan (60, Sec, 0, 0)
      Call Hydrosphere
    NextScan
  EndSequence
EndProg
